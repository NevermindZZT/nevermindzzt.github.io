<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Letter</title>
  
  <subtitle>Letter | Blog</subtitle>
  <link href="http://nevermindzzt.github.io/atom.xml" rel="self"/>
  
  <link href="http://nevermindzzt.github.io/"/>
  <updated>2021-02-21T10:50:11.768Z</updated>
  <id>http://nevermindzzt.github.io/</id>
  
  <author>
    <name>Letter</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android 音频框架分析</title>
    <link href="http://nevermindzzt.github.io/2020/10/15/Android%20%E9%9F%B3%E9%A2%91%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/"/>
    <id>http://nevermindzzt.github.io/2020/10/15/Android%20%E9%9F%B3%E9%A2%91%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/</id>
    <published>2020-10-15T02:45:00.000Z</published>
    <updated>2021-02-21T10:50:11.768Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p><img src="/../../out/source/_posts/Android%20%E9%9F%B3%E9%A2%91%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/Audio%20%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B.png" alt="Audio 初始化流程"></p><p>系统开机启动时，加载<code>init.rc</code>，启动<code>mediaserver</code>，在Android7.0之后，启动<code>mediaserver</code>的脚本被分离在了<code>audioserver.rc</code>文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">service media /system/bin/mediaserver</span><br><span class="line">    class main</span><br><span class="line">    user media</span><br><span class="line">    group audio camera inet net_bt net_bt_admin net_bw_acct drmrpc mediadrm</span><br><span class="line">    ioprio rt 4</span><br></pre></td></tr></table></figure><p><code>mediaserver</code>源码位置为<code>frameworks/av/media/mediaserver</code>，<code>mediaserver</code>目录中主要只有<code>main_mediaserver.cpp</code>一个文件，用于启动<code>AudioFlinger</code>, <code>AudioPolicyService</code>, <code>RadioService</code>等服务，其中与音频相关的主要是<code>AudioFlinger</code>和<code>AudioPolicyService</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc __unused, <span class="type">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> (doLog &amp;&amp; (childPid = fork()) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/** 启动log线程 */</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        AudioFlinger::<span class="built_in">instantiate</span>();</span><br><span class="line">        MediaPlayerService::<span class="built_in">instantiate</span>();</span><br><span class="line">        ResourceManagerService::<span class="built_in">instantiate</span>();</span><br><span class="line">        CameraService::<span class="built_in">instantiate</span>();</span><br><span class="line">        AudioPolicyService::<span class="built_in">instantiate</span>();</span><br><span class="line">        SoundTriggerHwService::<span class="built_in">instantiate</span>();</span><br><span class="line">        RadioService::<span class="built_in">instantiate</span>();</span><br><span class="line">        <span class="built_in">registerExtensions</span>();</span><br><span class="line">        ProcessState::<span class="built_in">self</span>()-&gt;<span class="built_in">startThreadPool</span>();</span><br><span class="line">        IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">joinThreadPool</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>AudioPolicyService</code>中，会在<code>onFristRef</code>方法中启动<code>AudioPolicyManager</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">AudioPolicyService::onFirstRef</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        ....</span><br><span class="line">        <span class="comment">// start tone playback thread</span></span><br><span class="line">        mTonePlaybackThread = <span class="keyword">new</span> <span class="built_in">AudioCommandThread</span>(<span class="built_in">String8</span>(<span class="string">&quot;ApmTone&quot;</span>, <span class="keyword">this</span>));</span><br><span class="line">        <span class="comment">// start audio commands thread</span></span><br><span class="line">        mTonePlaybackThread = <span class="keyword">new</span> <span class="built_in">AudioCommandThread</span>(<span class="built_in">String8</span>(<span class="string">&quot;ApmAudio&quot;</span>, <span class="keyword">this</span>));</span><br><span class="line">        <span class="comment">// start output activity command thread</span></span><br><span class="line">        mTonePlaybackThread = <span class="keyword">new</span> <span class="built_in">AudioCommandThread</span>(<span class="built_in">String8</span>(<span class="string">&quot;ApmOutput&quot;</span>, <span class="keyword">this</span>));</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_LEGACY_AUDIO_POLICY</span></span><br><span class="line">        <span class="comment">// 使用老版本的 audio policy 初始化方式</span></span><br><span class="line">        ....</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="comment">// 使用最新的 audio policy 初始化方式</span></span><br><span class="line">        <span class="built_in">ALOGI</span>(<span class="string">&quot;AudioPolicyService CSTOR in new mode&quot;</span>);</span><br><span class="line"></span><br><span class="line">        mAudioPolicyClient = <span class="keyword">new</span> <span class="built_in">AudioPolicyClient</span>(<span class="keyword">this</span>);</span><br><span class="line">        mAudioPolicyManager =<span class="built_in">createAudioPolicyManager</span>(mAudioPolicyClient);    <span class="comment">// 创建 AudioPolicyManager 对象</span></span><br><span class="line">        ....</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// load audio processing modules</span></span><br><span class="line">    sp&lt;AudioPolicyEffects&gt; audioPolicyEffects = <span class="keyword">new</span> <span class="built_in">AudioPolicyEffects</span>();</span><br><span class="line">    &#123;</span><br><span class="line">        ....</span><br><span class="line">        mAudioPolicyEffects = audioPolicyEffects;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createAudioPolicyManager</code>函数位于<code>frameworks/av/services/audiopolicy/manager/AudioPolicyFactory.cpp</code>文件，这个文件只有这一个函数，直接调用了<code>AudioPolicyManager</code>的构造函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">AudioPolicyInterface* <span class="title">createAudioPolicyManager</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        AudioPolicyClientInterface *clientInterface)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">AudioPolicyManager</span>(clientInterface);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>AudioPolicyManager</code>的构造函数中，会对<code>audio_policy.conf</code>文件(Android 7.0之后可以配置成audio_policy_configuration.xml)进行解析，加载所有的<code>HwModule</code>，创建输入输出流和播放、录音线程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">AudioPolicyManager::<span class="built_in">AudioPolicyManager</span>(AudioPolicyClientInterface *clientInterface)</span><br><span class="line">    :</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> AUDIO_POLICY_TEST</span></span><br><span class="line">    <span class="built_in">Thread</span>(<span class="literal">false</span>),</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//AUDIO_POLICY_TEST</span></span></span><br><span class="line">    <span class="built_in">mLimitRingtoneVolume</span>(<span class="literal">false</span>), <span class="built_in">mLastVoiceVolume</span>(<span class="number">-1.0f</span>),</span><br><span class="line">    <span class="built_in">mA2dpSuspended</span>(<span class="literal">false</span>),</span><br><span class="line">    <span class="built_in">mSpeakerDrcEnabled</span>(<span class="literal">false</span>),</span><br><span class="line">    <span class="built_in">mAudioPortGeneration</span>(<span class="number">1</span>),</span><br><span class="line">    <span class="built_in">mBeaconMuteRefCount</span>(<span class="number">0</span>),</span><br><span class="line">    <span class="built_in">mBeaconPlayingRefCount</span>(<span class="number">0</span>),</span><br><span class="line">    <span class="built_in">mBeaconMuted</span>(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/** 加载audio_policy.conf文件 */</span></span><br><span class="line">    <span class="keyword">if</span> (ConfigParsingUtils::<span class="built_in">loadAudioPolicyConfig</span>(AUDIO_POLICY_VENDOR_CONFIG_FILE,</span><br><span class="line">                 mHwModules, mAvailableInputDevices, mAvailableOutputDevices,</span><br><span class="line">                 mDefaultOutputDevice, mSpeakerDrcEnabled) != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ConfigParsingUtils::<span class="built_in">loadAudioPolicyConfig</span>(AUDIO_POLICY_CONFIG_FILE,</span><br><span class="line">                                  mHwModules, mAvailableInputDevices, mAvailableOutputDevices,</span><br><span class="line">                                  mDefaultOutputDevice, mSpeakerDrcEnabled) != NO_ERROR) &#123;</span><br><span class="line">            <span class="built_in">ALOGE</span>(<span class="string">&quot;could not load audio policy configuration file, setting defaults&quot;</span>);</span><br><span class="line">            <span class="built_in">defaultAudioPolicyConfig</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// mAvailableOutputDevices and mAvailableInputDevices now contain all attached devices</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// must be done after reading the policy (since conditionned by Speaker Drc Enabling)</span></span><br><span class="line">    <span class="comment">/** 调节音量曲线 */</span></span><br><span class="line">    mEngine-&gt;<span class="built_in">initializeVolumeCurves</span>(mSpeakerDrcEnabled);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// open all output streams needed to access attached devices</span></span><br><span class="line">    <span class="type">audio_devices_t</span> outputDeviceTypes = mAvailableOutputDevices.<span class="built_in">types</span>();</span><br><span class="line">    <span class="type">audio_devices_t</span> inputDeviceTypes = mAvailableInputDevices.<span class="built_in">types</span>() &amp; ~AUDIO_DEVICE_BIT_IN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; mHwModules.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        mHwModules[i]-&gt;mHandle = mpClientInterface-&gt;<span class="built_in">loadHwModule</span>(mHwModules[i]-&gt;mName);</span><br><span class="line">        <span class="keyword">if</span> (mHwModules[i]-&gt;mHandle == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">ALOGW</span>(<span class="string">&quot;could not open HW module %s&quot;</span>, mHwModules[i]-&gt;mName);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// open all output streams needed to access attached devices</span></span><br><span class="line">        <span class="comment">// except for direct output streams that are only opened when they are actually</span></span><br><span class="line">        <span class="comment">// required by an app.</span></span><br><span class="line">        <span class="comment">// This also validates mAvailableOutputDevices list</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; mHwModules[i]-&gt;mOutputProfiles.<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">const</span> sp&lt;IOProfile&gt; outProfile = mHwModules[i]-&gt;mOutputProfiles[j];</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">/** 获取采样率、通道数、数据格式等各音频参数 */</span></span><br><span class="line">            outputDesc-&gt;mDevice = profileType;</span><br><span class="line">            <span class="type">audio_config_t</span> config = AUDIO_CONFIG_INITIALIZER;</span><br><span class="line">            config.sample_rate = outputDesc-&gt;mSamplingRate;</span><br><span class="line">            config.channel_mask = outputDesc-&gt;mChannelMask;</span><br><span class="line">            config.format = outputDesc-&gt;mFormat;</span><br><span class="line">            <span class="type">audio_io_handle_t</span> output = AUDIO_IO_HANDLE_NONE;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/** 打开 outputStream 创建 playbackThread 线程 */</span></span><br><span class="line">            <span class="type">status_t</span> status = mpClientInterface-&gt;<span class="built_in">openOutput</span>(outProfile-&gt;<span class="built_in">getModuleHandle</span>(),</span><br><span class="line">                                                            &amp;output,</span><br><span class="line">                                                            &amp;config,</span><br><span class="line">                                                            &amp;outputDesc-&gt;mDevice,</span><br><span class="line">                                                            <span class="built_in">String8</span>(<span class="string">&quot;&quot;</span>),</span><br><span class="line">                                                            &amp;outputDesc-&gt;mLatency,</span><br><span class="line">                                                            outputDesc-&gt;mFlags);</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// open input streams needed to access attached devices to validate</span></span><br><span class="line">        <span class="comment">// mAvailableInputDevices list</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; mHwModules[i]-&gt;mInputProfiles.<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">const</span> sp&lt;IOProfile&gt; inProfile = mHwModules[i]-&gt;mInputProfiles[j];</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">/** 获取采样率、通道数、数据格式等各音频参数 */</span></span><br><span class="line">            <span class="type">audio_config_t</span> config = AUDIO_CONFIG_INITIALIZER;</span><br><span class="line">            config.sample_rate = inputDesc-&gt;mSamplingRate;</span><br><span class="line">            config.channel_mask = inputDesc-&gt;mChannelMask;</span><br><span class="line">            config.format = inputDesc-&gt;mFormat;</span><br><span class="line">            <span class="type">audio_io_handle_t</span> input = AUDIO_IO_HANDLE_NONE;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/** 打开 inputStream 创建 recordThread  线程 */</span></span><br><span class="line">            <span class="type">status_t</span> status = mpClientInterface-&gt;<span class="built_in">openInput</span>(inProfile-&gt;<span class="built_in">getModuleHandle</span>(),</span><br><span class="line">                                                           &amp;input,</span><br><span class="line">                                                           &amp;config,</span><br><span class="line">                                                           &amp;inputDesc-&gt;mDevice,</span><br><span class="line">                                                           address,</span><br><span class="line">                                                           AUDIO_SOURCE_MIC,</span><br><span class="line">                                                           AUDIO_INPUT_FLAG_NONE);</span><br><span class="line"></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/** 更新系统缓存的音频输出设备信息 */</span></span><br><span class="line">    <span class="built_in">updateDevicesAndOutputs</span>();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置文件加载"><a href="#配置文件加载" class="headerlink" title="配置文件加载"></a>配置文件加载</h2><p><code>audio_policy.conf</code>文件用于配置系统的音频设备，在<code>AudioPolicyManager</code>的构造方法中加载解析，通过<code>ConfigParsingUtils</code>的<code>loadAudioPolicyConfig</code>函数，解析这个文件，获取所有配置的输入输出设备类型以及各项配置，然后对所有获取到的<code>HwModule</code>进行遍历，通过<code>AudioFlinger</code>加载对应的so，生成音频设备</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">audio_module_handle_t</span> <span class="title">AudioFlinger::loadHwModule_l</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">audio_hw_device_t</span> *dev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 加载so */</span></span><br><span class="line">    <span class="type">int</span> rc = <span class="built_in">load_audio_interface</span>(name, &amp;dev);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 添加音频设备 */</span></span><br><span class="line">    <span class="type">audio_module_handle_t</span> handle = <span class="built_in">nextUniqueId</span>();</span><br><span class="line">    mAudioHwDevs.<span class="built_in">add</span>(handle, <span class="keyword">new</span> <span class="built_in">AudioHwDevice</span>(handle, name, dev, flags));</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> handle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>load_audio_interface</code>函数中，会从<code>system/lib/hw</code>中找到对应于<code>name</code>的库，一般为<code>audio.[name].default.so</code>，这个库由音频设备商提供，系统默认的音频设备库由<code>hardware/mstar/audio</code>编译生成，对应<code>primary</code>的设备</p><p><code>audio_hw_device_t</code>为音频设备的实现，结构体在<code>hardware/libhardware/include/hardware/audio.h</code>中定义，每一个音频设备驱动都需要实现这个结构体定义的各个函数，所有操作音频设备都是通过这个结构体生成的对象实现的</p><h2 id="录音调用流程"><a href="#录音调用流程" class="headerlink" title="录音调用流程"></a>录音调用流程</h2><p><img src="/../../out/source/_posts/Android%20%E9%9F%B3%E9%A2%91%E6%A1%86%E6%9E%B6%E5%88%86%E6%9E%90/%E5%BD%95%E9%9F%B3%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B/Audio%20%E5%BD%95%E9%9F%B3%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B.png" alt="Audio 录音调用流程"></p><p>一般情况下，录音由Android App通过<code>AudioRecord</code>发起，<code>AudioRecord</code>通过jni调用Android框架libmedia中的<code>AudioRecord</code>，<code>AudioRecord</code>的构造函数直接调用<code>set</code>函数，在<code>set</code>函数中，会首先进行一些参数的设置，然后运行<code>recordThread</code>，打开录音设备(<code>IAudioRecord</code>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">AudioRecord::set</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">audio_source_t</span> inputSource,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">uint32_t</span> sampleRate,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">audio_format_t</span> format,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">audio_channel_mask_t</span> channelMask,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">size_t</span> frameCount,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">callback_t</span> cbf,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">void</span>* user,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">uint32_t</span> notificationFrames,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">bool</span> threadCanCallJava,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> sessionId,</span></span></span><br><span class="line"><span class="params"><span class="function">        transfer_type transferType,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">audio_input_flags_t</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> uid,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">pid_t</span> pid,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="type">audio_attributes_t</span>* pAttributes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/** 设置参数 */</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 打开 recordThread */</span></span><br><span class="line">    <span class="keyword">if</span> (cbf != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        mAudioRecordThread = <span class="keyword">new</span> <span class="built_in">AudioRecordThread</span>(*<span class="keyword">this</span>, threadCanCallJava);</span><br><span class="line">        mAudioRecordThread-&gt;<span class="built_in">run</span>(<span class="string">&quot;AudioRecord&quot;</span>, ANDROID_PRIORITY_AUDIO);</span><br><span class="line">        <span class="comment">// thread begins in paused state, and will not reference us until start()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create the IAudioRecord</span></span><br><span class="line">    <span class="type">status_t</span> status = <span class="built_in">openRecord_l</span>(<span class="number">0</span> <span class="comment">/*epoch*/</span>, mOpPackageName);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>set</code>函数调用了<code>openRecord_l</code>函数，在<code>openRecord_l</code>函数中，首先获取了<code>AudioFlinger</code>的实例，然后通过构造<code>AudioRecord</code>时传进来的参数，获取对应的<code>audio_io_handle_t</code>句柄</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">audio_io_handle_t</span> input;</span><br><span class="line"><span class="type">status_t</span> status = AudioSystem::<span class="built_in">getInputForAttr</span>(&amp;mAttributes, &amp;input,</span><br><span class="line">                                    (<span class="type">audio_session_t</span>)mSessionId,</span><br><span class="line">                                    IPCThreadState::<span class="built_in">self</span>()-&gt;<span class="built_in">getCallingUid</span>(),</span><br><span class="line">                                    mSampleRate, mFormat, mChannelMask,</span><br><span class="line">                                    mFlags, mSelectedDeviceId);</span><br></pre></td></tr></table></figure><p>然后，通过<code>AudioFlinger</code>打开录音</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IAudioRecord&gt; record = audioFlinger-&gt;<span class="built_in">openRecord</span>(input,</span><br><span class="line">                                                   mSampleRate,</span><br><span class="line">                                                   mFormat,</span><br><span class="line">                                                   mChannelMask,</span><br><span class="line">                                                   opPackageName,</span><br><span class="line">                                                   &amp;temp,</span><br><span class="line">                                                   &amp;trackFlags,</span><br><span class="line">                                                   tid,</span><br><span class="line">                                                   mClientUid,</span><br><span class="line">                                                   &amp;mSessionId,</span><br><span class="line">                                                   &amp;notificationFrames,</span><br><span class="line">                                                   iMem,</span><br><span class="line">                                                   bufferMem,</span><br><span class="line">                                                   &amp;status);</span><br></pre></td></tr></table></figure><h2 id="录音设备选择"><a href="#录音设备选择" class="headerlink" title="录音设备选择"></a>录音设备选择</h2><p>录音调用流程中，在<code>AudioRecord</code>的构造函数中，通过<code>set</code>函数调用了<code>AudioSystem::getInputForAttr</code>以获得匹配的录音设备，我们着重关注第一个参数<code>mAttributes</code></p><p>在Android App中，我们通过实例化一个<code>AudioRecord(java)</code>来进行录音，通常调用的构造方法为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">AudioRecord</span><span class="params">(<span class="type">int</span> audioSource, <span class="type">int</span> sampleRateInHz, <span class="type">int</span> channelConfig, <span class="type">int</span> audioFormat,</span></span><br><span class="line"><span class="params">        <span class="type">int</span> bufferSizeInBytes)</span></span><br><span class="line"><span class="keyword">throws</span> IllegalArgumentException &#123;</span><br><span class="line">    <span class="built_in">this</span>((<span class="keyword">new</span> <span class="title class_">AudioAttributes</span>.Builder())</span><br><span class="line">                .setInternalCapturePreset(audioSource)</span><br><span class="line">                .build(),</span><br><span class="line">            (<span class="keyword">new</span> <span class="title class_">AudioFormat</span>.Builder())</span><br><span class="line">                .setChannelMask(getChannelMaskFromLegacyConfig(channelConfig,</span><br><span class="line">                                    <span class="literal">true</span><span class="comment">/*allow legacy configurations*/</span>))</span><br><span class="line">                .setEncoding(audioFormat)</span><br><span class="line">                .setSampleRate(sampleRateInHz)</span><br><span class="line">                .build(),</span><br><span class="line">            bufferSizeInBytes,</span><br><span class="line">            AudioManager.AUDIO_SESSION_ID_GENERATE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里需要传递<code>audioSource</code>，<code>sampleRateInHz</code>等参数，并将这些参数构造成了一个<code>AudioAttributes</code>的对象，其中<code>audioSource</code>就是选择的音频源，在Android App端，可以选择的源如下(<code>frameworks/base/media/java/android/media/MediaRecorder.java</code>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">AudioSource</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">AudioSource</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">AUDIO_SOURCE_INVALID</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Do not change these values without updating their counterparts</span></span><br><span class="line"><span class="comment">   * in system/media/audio/include/system/audio.h!</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Default audio source **/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Microphone audio source */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIC</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Voice call uplink (Tx) audio source */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">VOICE_UPLINK</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Voice call downlink (Rx) audio source */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">VOICE_DOWNLINK</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Voice call uplink + downlink audio source */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">VOICE_CALL</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Microphone audio source with same orientation as camera if available, the main</span></span><br><span class="line"><span class="comment">     *  device microphone otherwise */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CAMCORDER</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Microphone audio source tuned for voice recognition if available, behaves like</span></span><br><span class="line"><span class="comment">     *  &#123;<span class="doctag">@link</span> #DEFAULT&#125; otherwise. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">VOICE_RECOGNITION</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Microphone audio source tuned for voice communications such as VoIP. It</span></span><br><span class="line"><span class="comment">     *  will for instance take advantage of echo cancellation or automatic gain control</span></span><br><span class="line"><span class="comment">     *  if available. It otherwise behaves like &#123;<span class="doctag">@link</span> #DEFAULT&#125; if no voice processing</span></span><br><span class="line"><span class="comment">     *  is applied.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">VOICE_COMMUNICATION</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Audio source for a submix of audio streams to be presented remotely.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * An application can use this audio source to capture a mix of audio streams</span></span><br><span class="line"><span class="comment">     * that should be transmitted to a remote receiver such as a Wifi display.</span></span><br><span class="line"><span class="comment">     * While recording is active, these audio streams are redirected to the remote</span></span><br><span class="line"><span class="comment">     * submix instead of being played on the device speaker or headset.</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;&lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Certain streams are excluded from the remote submix, including</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> AudioManager#STREAM_RING&#125;, &#123;<span class="doctag">@link</span> AudioManager#STREAM_ALARM&#125;,</span></span><br><span class="line"><span class="comment">     * and &#123;<span class="doctag">@link</span> AudioManager#STREAM_NOTIFICATION&#125;.  These streams will continue</span></span><br><span class="line"><span class="comment">     * to be presented locally as usual.</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;&lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Capturing the remote submix audio requires the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> android.Manifest.permission#CAPTURE_AUDIO_OUTPUT&#125; permission.</span></span><br><span class="line"><span class="comment">     * This permission is reserved for use by system components and is not available to</span></span><br><span class="line"><span class="comment">     * third-party applications.</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">REMOTE_SUBMIX</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MStar Android Patch Begin</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">     * BT PCM data send from remote devices which needs to be processed as PCM input</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">BT_MIC</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">    <span class="comment">// MStar Android Patch End</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Audio source for capturing broadcast radio tuner output.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SystemApi</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RADIO_TUNER</span> <span class="operator">=</span> <span class="number">1998</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Audio source for preemptible, low-priority software hotword detection</span></span><br><span class="line"><span class="comment">     * It presents the same gain and pre processing tuning as &#123;<span class="doctag">@link</span> #VOICE_RECOGNITION&#125;.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * An application should use this audio source when it wishes to do</span></span><br><span class="line"><span class="comment">     * always-on software hotword detection, while gracefully giving in to any other application</span></span><br><span class="line"><span class="comment">     * that might want to read from the microphone.</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     * This is a hidden audio source.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SystemApi</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">HOTWORD</span> <span class="operator">=</span> <span class="number">1999</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>传递进来的参数jni，调用到<code>AudioRecord(cpp)</code>的<code>set</code>函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">AudioRecord::set</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">audio_source_t</span> inputSource,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">uint32_t</span> sampleRate,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">audio_format_t</span> format,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">audio_channel_mask_t</span> channelMask,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">size_t</span> frameCount,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">callback_t</span> cbf,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">void</span>* user,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">uint32_t</span> notificationFrames,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">bool</span> threadCanCallJava,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> sessionId,</span></span></span><br><span class="line"><span class="params"><span class="function">        transfer_type transferType,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">audio_input_flags_t</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> uid,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">pid_t</span> pid,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> <span class="type">audio_attributes_t</span>* pAttributes)</span></span></span><br></pre></td></tr></table></figure><p>在这里，<code>inputSource</code>即表示音频源，<code>audio_source_t</code>在<code>audio.h</code>中定义(<code>system/media/audio/include/system/audio.h</code>)且与<code>AudioSource</code>中的定义一一对应</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    AUDIO_SOURCE_DEFAULT             = <span class="number">0</span>,</span><br><span class="line">    AUDIO_SOURCE_MIC                 = <span class="number">1</span>,</span><br><span class="line">    AUDIO_SOURCE_VOICE_UPLINK        = <span class="number">2</span>,</span><br><span class="line">    AUDIO_SOURCE_VOICE_DOWNLINK      = <span class="number">3</span>,</span><br><span class="line">    AUDIO_SOURCE_VOICE_CALL          = <span class="number">4</span>,</span><br><span class="line">    AUDIO_SOURCE_CAMCORDER           = <span class="number">5</span>,</span><br><span class="line">    AUDIO_SOURCE_VOICE_RECOGNITION   = <span class="number">6</span>,</span><br><span class="line">    AUDIO_SOURCE_VOICE_COMMUNICATION = <span class="number">7</span>,</span><br><span class="line">    AUDIO_SOURCE_REMOTE_SUBMIX       = <span class="number">8</span>, <span class="comment">/* Source for the mix to be presented remotely.      */</span></span><br><span class="line">                                          <span class="comment">/* An example of remote presentation is Wifi Display */</span></span><br><span class="line">                                          <span class="comment">/*  where a dongle attached to a TV can be used to   */</span></span><br><span class="line">                                          <span class="comment">/*  play the mix captured by this audio source.      */</span></span><br><span class="line">    <span class="comment">// MStar Android Patch Begin</span></span><br><span class="line">    AUDIO_SOURCE_BLUETOOTH_MIC       = <span class="number">9</span>,</span><br><span class="line">    AUDIO_SOURCE_CAPTURE_DEVICE0     = <span class="number">10</span>,</span><br><span class="line">    AUDIO_SOURCE_CAPTURE_DEVICE1     = <span class="number">11</span>,</span><br><span class="line">    AUDIO_SOURCE_A2DP                = <span class="number">12</span>, <span class="comment">/* restricted to internal audioflinger routing */</span></span><br><span class="line">    <span class="comment">// MStar Android Patch End</span></span><br><span class="line">    AUDIO_SOURCE_CNT,</span><br><span class="line">    AUDIO_SOURCE_MAX                 = AUDIO_SOURCE_CNT - <span class="number">1</span>,</span><br><span class="line">    AUDIO_SOURCE_FM_TUNER            = <span class="number">1998</span>,</span><br><span class="line">    AUDIO_SOURCE_HOTWORD             = <span class="number">1999</span>, <span class="comment">/* A low-priority, preemptible audio source for</span></span><br><span class="line"><span class="comment">                                                for background software hotword detection.</span></span><br><span class="line"><span class="comment">                                                Same tuning as AUDIO_SOURCE_VOICE_RECOGNITION.</span></span><br><span class="line"><span class="comment">                                                Used only internally to the framework. Not exposed</span></span><br><span class="line"><span class="comment">                                                at the audio HAL. */</span></span><br><span class="line">&#125; <span class="type">audio_source_t</span>;</span><br></pre></td></tr></table></figure><p>我们再回头看<code>getInputForAttr</code>函数(<code>frameworks/av/media/libmedia/AudioSystem.cpp</code>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">AudioSystem::getInputForAttr</span><span class="params">(<span class="type">const</span> <span class="type">audio_attributes_t</span> *attr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">audio_io_handle_t</span> *input,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">audio_session_t</span> session,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">uid_t</span> uid,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">uint32_t</span> samplingRate,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">audio_format_t</span> format,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">audio_channel_mask_t</span> channelMask,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">audio_input_flags_t</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">audio_port_handle_t</span> selectedDeviceId)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> sp&lt;IAudioPolicyService&gt;&amp; aps = AudioSystem::<span class="built_in">get_audio_policy_service</span>();</span><br><span class="line">    <span class="keyword">if</span> (aps == <span class="number">0</span>) <span class="keyword">return</span> NO_INIT;</span><br><span class="line">    <span class="keyword">return</span> aps-&gt;<span class="built_in">getInputForAttr</span>(</span><br><span class="line">            attr, input, session, uid, samplingRate, format, channelMask, flags, selectedDeviceId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这里直接调用的<code>AudioPolicyService</code>的<code>getInputForAttr</code>函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">status_t</span> <span class="title">AudioPolicyManager::getInputForAttr</span><span class="params">(<span class="type">const</span> <span class="type">audio_attributes_t</span> *attr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="type">audio_io_handle_t</span> *input,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="type">audio_session_t</span> session,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="type">uid_t</span> uid,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="type">uint32_t</span> samplingRate,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="type">audio_format_t</span> format,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="type">audio_channel_mask_t</span> channelMask,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="type">audio_input_flags_t</span> flags,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="type">audio_port_handle_t</span> selectedDeviceId,</span></span></span><br><span class="line"><span class="params"><span class="function">                                             <span class="type">input_type_t</span> *inputType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *input = AUDIO_IO_HANDLE_NONE;</span><br><span class="line">    *inputType = API_INPUT_INVALID;</span><br><span class="line">    <span class="type">audio_devices_t</span> device;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (inputSource == AUDIO_SOURCE_REMOTE_SUBMIX &amp;&amp;</span><br><span class="line">            <span class="built_in">strncmp</span>(attr-&gt;tags, <span class="string">&quot;addr=&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;addr=&quot;</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">status_t</span> ret = mPolicyMixes.<span class="built_in">getInputMixForAttr</span>(*attr, &amp;policyMix);</span><br><span class="line">        <span class="keyword">if</span> (ret != NO_ERROR) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        *inputType = API_INPUT_MIX_EXT_POLICY_REROUTE;</span><br><span class="line">        device = AUDIO_DEVICE_IN_REMOTE_SUBMIX;</span><br><span class="line">        address = <span class="built_in">String8</span>(attr-&gt;tags + <span class="built_in">strlen</span>(<span class="string">&quot;addr=&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        device = <span class="built_in">getDeviceAndMixForInputSource</span>(inputSource, &amp;policyMix);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里先判断<code>inputSource</code>是否为<code>AUDIO_SOURCE_REMOTE_SUBMIX</code>，如果时其他源，则调用<code>getDeviceAndMixForInputSource</code>函数</p><p>这里我们注意一下<code>audio_devices_t</code>这个数据类型，在<code>audio.h</code>中定义，这个数据类型就表示一个具体类型的音频设备，我们再<code>audio_polic.conf</code>中定义音频设备时，<code>device</code>字段的取值就需要是这个数据类型中定义的值</p><p>再来看<code>getDeviceAndMixForInputSource</code>函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">audio_devices_t</span> <span class="title">AudioPolicyManager::getDeviceAndMixForInputSource</span><span class="params">(<span class="type">audio_source_t</span> inputSource,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                                  AudioMix **policyMix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">audio_devices_t</span> availableDeviceTypes = mAvailableInputDevices.<span class="built_in">types</span>() &amp; ~AUDIO_DEVICE_BIT_IN;</span><br><span class="line">    <span class="type">audio_devices_t</span> selectedDeviceFromMix =</span><br><span class="line">           mPolicyMixes.<span class="built_in">getDeviceAndMixForInputSource</span>(inputSource, availableDeviceTypes, policyMix);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (selectedDeviceFromMix != AUDIO_DEVICE_NONE) &#123;</span><br><span class="line">        <span class="keyword">return</span> selectedDeviceFromMix;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getDeviceForInputSource</span>(inputSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先调用了<code>getDeviceAndMixForInputSource</code>函数，这个应该是混音通道，我们先不看，一般情况，我们调用录音，会走到<code>getDeviceForInputSource</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">audio_devices_t</span> <span class="title">AudioPolicyManager::getDeviceForInputSource</span><span class="params">(<span class="type">audio_source_t</span> inputSource)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> routeIndex = <span class="number">0</span>; routeIndex &lt; mInputRoutes.<span class="built_in">size</span>(); routeIndex++) &#123;</span><br><span class="line">         sp&lt;SessionRoute&gt; route = mInputRoutes.<span class="built_in">valueAt</span>(routeIndex);</span><br><span class="line">         <span class="keyword">if</span> (inputSource == route-&gt;mSource &amp;&amp; route-&gt;<span class="built_in">isActive</span>()) &#123;</span><br><span class="line">             <span class="keyword">return</span> route-&gt;mDeviceDescriptor-&gt;<span class="built_in">type</span>();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> mEngine-&gt;<span class="built_in">getDeviceForInputSource</span>(inputSource);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getDeviceForInputSource</code>函数直接调用了<code>Engine</code>的<code>getDeviceForInputSource</code>函数(<code>frameworks/av/services/audiopolicy/enginedefault/src/Engine.cpp</code>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">audio_devices_t</span> <span class="title">Engine::getDeviceForInputSource</span><span class="params">(<span class="type">audio_source_t</span> inputSource)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> DeviceVector &amp;availableOutputDevices = mApmObserver-&gt;<span class="built_in">getAvailableOutputDevices</span>();</span><br><span class="line">    <span class="type">const</span> DeviceVector &amp;availableInputDevices = mApmObserver-&gt;<span class="built_in">getAvailableInputDevices</span>();</span><br><span class="line">    <span class="type">const</span> SwAudioOutputCollection &amp;outputs = mApmObserver-&gt;<span class="built_in">getOutputs</span>();</span><br><span class="line">    <span class="type">audio_devices_t</span> availableDeviceTypes = availableInputDevices.<span class="built_in">types</span>() &amp; ~AUDIO_DEVICE_BIT_IN;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> device = AUDIO_DEVICE_NONE;</span><br><span class="line">    <span class="comment">// MStar Android Patch Begin</span></span><br><span class="line">    <span class="type">char</span> value[PROPERTY_VALUE_MAX] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// MStar Android Patch End</span></span><br><span class="line">    <span class="keyword">switch</span> (inputSource) &#123;</span><br><span class="line">    <span class="keyword">case</span> AUDIO_SOURCE_VOICE_UPLINK:</span><br><span class="line">      <span class="keyword">if</span> (availableDeviceTypes &amp; AUDIO_DEVICE_IN_VOICE_CALL) &#123;</span><br><span class="line">          device = AUDIO_DEVICE_IN_VOICE_CALL;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> AUDIO_SOURCE_DEFAULT:</span><br><span class="line">    <span class="keyword">case</span> AUDIO_SOURCE_MIC:</span><br><span class="line">    <span class="keyword">if</span> (availableDeviceTypes &amp; AUDIO_DEVICE_IN_BLUETOOTH_A2DP) &#123;</span><br><span class="line">        device = AUDIO_DEVICE_IN_BLUETOOTH_A2DP;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((mForceUse[AUDIO_POLICY_FORCE_FOR_RECORD] == AUDIO_POLICY_FORCE_BT_SCO) &amp;&amp;</span><br><span class="line">        (availableDeviceTypes &amp; AUDIO_DEVICE_IN_BLUETOOTH_SCO_HEADSET)) &#123;</span><br><span class="line">        device = AUDIO_DEVICE_IN_BLUETOOTH_SCO_HEADSET;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (availableDeviceTypes &amp; AUDIO_DEVICE_IN_WIRED_HEADSET) &#123;</span><br><span class="line">        device = AUDIO_DEVICE_IN_WIRED_HEADSET;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (availableDeviceTypes &amp; AUDIO_DEVICE_IN_USB_DEVICE) &#123;</span><br><span class="line">        device = AUDIO_DEVICE_IN_USB_DEVICE;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (availableDeviceTypes &amp; AUDIO_DEVICE_IN_BUILTIN_MIC) &#123;</span><br><span class="line">        device = AUDIO_DEVICE_IN_BUILTIN_MIC;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> AUDIO_SOURCE_VOICE_COMMUNICATION:</span><br><span class="line">        <span class="comment">// Allow only use of devices on primary input if in call and HAL does not support routing</span></span><br><span class="line">        <span class="comment">// to voice call path.</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">getPhoneState</span>() == AUDIO_MODE_IN_CALL) &amp;&amp;</span><br><span class="line">                (availableOutputDevices.<span class="built_in">types</span>() &amp; AUDIO_DEVICE_OUT_TELEPHONY_TX) == <span class="number">0</span>) &#123;</span><br><span class="line">            sp&lt;AudioOutputDescriptor&gt; primaryOutput = outputs.<span class="built_in">getPrimaryOutput</span>();</span><br><span class="line">            availableDeviceTypes =</span><br><span class="line">                    availableInputDevices.<span class="built_in">getDevicesFromHwModule</span>(primaryOutput-&gt;<span class="built_in">getModuleHandle</span>())</span><br><span class="line">                    &amp; ~AUDIO_DEVICE_BIT_IN;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (mForceUse[AUDIO_POLICY_FORCE_FOR_COMMUNICATION]) &#123;</span><br><span class="line">        <span class="keyword">case</span> AUDIO_POLICY_FORCE_BT_SCO:</span><br><span class="line">            <span class="comment">// if SCO device is requested but no SCO device is available, fall back to default case</span></span><br><span class="line">            <span class="keyword">if</span> (availableDeviceTypes &amp; AUDIO_DEVICE_IN_BLUETOOTH_SCO_HEADSET) &#123;</span><br><span class="line">                device = AUDIO_DEVICE_IN_BLUETOOTH_SCO_HEADSET;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// FALL THROUGH</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:    <span class="comment">// FORCE_NONE</span></span><br><span class="line">            <span class="keyword">if</span> (availableDeviceTypes &amp; AUDIO_DEVICE_IN_WIRED_HEADSET) &#123;</span><br><span class="line">                device = AUDIO_DEVICE_IN_WIRED_HEADSET;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (availableDeviceTypes &amp; AUDIO_DEVICE_IN_USB_DEVICE) &#123;</span><br><span class="line">                device = AUDIO_DEVICE_IN_USB_DEVICE;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (availableDeviceTypes &amp; AUDIO_DEVICE_IN_BUILTIN_MIC) &#123;</span><br><span class="line">                device = AUDIO_DEVICE_IN_BUILTIN_MIC;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> AUDIO_POLICY_FORCE_SPEAKER:</span><br><span class="line">            <span class="keyword">if</span> (availableDeviceTypes &amp; AUDIO_DEVICE_IN_BACK_MIC) &#123;</span><br><span class="line">                device = AUDIO_DEVICE_IN_BACK_MIC;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (availableDeviceTypes &amp; AUDIO_DEVICE_IN_BUILTIN_MIC) &#123;</span><br><span class="line">                device = AUDIO_DEVICE_IN_BUILTIN_MIC;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MStar Android Patch Begin</span></span><br><span class="line">    <span class="keyword">case</span> AUDIO_SOURCE_BLUETOOTH_MIC:</span><br><span class="line">        <span class="keyword">if</span> (mForceUse[AUDIO_POLICY_FORCE_FOR_RECORD] == AUDIO_POLICY_FORCE_BT_MIC &amp;&amp;</span><br><span class="line">                availableDeviceTypes &amp; AUDIO_DEVICE_IN_BLUETOOTH_MIC) &#123;</span><br><span class="line">                device = AUDIO_DEVICE_IN_BLUETOOTH_MIC;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (availableDeviceTypes &amp; AUDIO_DEVICE_IN_BACK_MIC) &#123;</span><br><span class="line">            device = AUDIO_DEVICE_IN_BACK_MIC;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// MStar Android Patch End</span></span><br><span class="line">    <span class="keyword">case</span> AUDIO_SOURCE_VOICE_RECOGNITION:</span><br><span class="line">    <span class="keyword">case</span> AUDIO_SOURCE_HOTWORD:</span><br><span class="line">        <span class="keyword">if</span> (mForceUse[AUDIO_POLICY_FORCE_FOR_RECORD] == AUDIO_POLICY_FORCE_BT_SCO &amp;&amp;</span><br><span class="line">                availableDeviceTypes &amp; AUDIO_DEVICE_IN_BLUETOOTH_SCO_HEADSET) &#123;</span><br><span class="line">            device = AUDIO_DEVICE_IN_BLUETOOTH_SCO_HEADSET;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (availableDeviceTypes &amp; AUDIO_DEVICE_IN_WIRED_HEADSET) &#123;</span><br><span class="line">            device = AUDIO_DEVICE_IN_WIRED_HEADSET;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (availableDeviceTypes &amp; AUDIO_DEVICE_IN_USB_DEVICE) &#123;</span><br><span class="line">            device = AUDIO_DEVICE_IN_USB_DEVICE;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (availableDeviceTypes &amp; AUDIO_DEVICE_IN_BUILTIN_MIC) &#123;</span><br><span class="line">            device = AUDIO_DEVICE_IN_BUILTIN_MIC;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// MStar Android Patch Begin</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">property_get</span>(<span class="string">&quot;mstar.bt.driver&quot;</span>, value, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(value, <span class="string">&quot;bcm&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mForceUse[AUDIO_POLICY_FORCE_FOR_RECORD] == AUDIO_POLICY_FORCE_BT_MIC &amp;&amp;</span><br><span class="line">                    (inputSource == AUDIO_SOURCE_VOICE_RECOGNITION ||</span><br><span class="line">                    inputSource == AUDIO_SOURCE_MIC)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (availableDeviceTypes &amp; AUDIO_DEVICE_IN_BACK_MIC) &#123;</span><br><span class="line">                        device = AUDIO_DEVICE_IN_BACK_MIC;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        device = AUDIO_DEVICE_IN_BLUETOOTH_MIC;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">ALOGE</span>(<span class="string">&quot;picked the Broadcom MIC&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(value, <span class="string">&quot;mtk&quot;</span>) || !<span class="built_in">strcmp</span>(value, <span class="string">&quot;rtk&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((inputSource == AUDIO_SOURCE_VOICE_RECOGNITION ||</span><br><span class="line">                    inputSource == AUDIO_SOURCE_MIC)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (availableDeviceTypes &amp; AUDIO_DEVICE_IN_BACK_MIC) &#123;</span><br><span class="line">                        device = AUDIO_DEVICE_IN_BACK_MIC;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        device = AUDIO_DEVICE_IN_BLUETOOTH_MIC;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">ALOGE</span>(<span class="string">&quot;picked the MtkRc MIC&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//other bt to do ???</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">ALOGE</span>(<span class="string">&quot;%s device:%x &quot;</span>, __FUNCTION__, device);</span><br><span class="line">        <span class="comment">// MStar Android Patch End</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AUDIO_SOURCE_CAMCORDER:</span><br><span class="line">        <span class="keyword">if</span> (availableDeviceTypes &amp; AUDIO_DEVICE_IN_BACK_MIC) &#123;</span><br><span class="line">            device = AUDIO_DEVICE_IN_BACK_MIC;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (availableDeviceTypes &amp; AUDIO_DEVICE_IN_BUILTIN_MIC) &#123;</span><br><span class="line">            device = AUDIO_DEVICE_IN_BUILTIN_MIC;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AUDIO_SOURCE_VOICE_DOWNLINK:</span><br><span class="line">    <span class="keyword">case</span> AUDIO_SOURCE_VOICE_CALL:</span><br><span class="line">        <span class="keyword">if</span> (availableDeviceTypes &amp; AUDIO_DEVICE_IN_VOICE_CALL) &#123;</span><br><span class="line">            device = AUDIO_DEVICE_IN_VOICE_CALL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> AUDIO_SOURCE_REMOTE_SUBMIX:</span><br><span class="line">        <span class="keyword">if</span> (availableDeviceTypes &amp; AUDIO_DEVICE_IN_REMOTE_SUBMIX) &#123;</span><br><span class="line">            device = AUDIO_DEVICE_IN_REMOTE_SUBMIX;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> AUDIO_SOURCE_FM_TUNER:</span><br><span class="line">        <span class="comment">//if (availableDeviceTypes &amp; AUDIO_DEVICE_IN_FM_TUNER) &#123;</span></span><br><span class="line">        <span class="comment">//    device = AUDIO_DEVICE_IN_FM_TUNER;</span></span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">        device = AUDIO_DEVICE_IN_BLUETOOTH_A2DP;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">ALOGW</span>(<span class="string">&quot;getDeviceForInputSource() invalid input source %d&quot;</span>, inputSource);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ALOGE</span>(<span class="string">&quot;getDeviceForInputSource()input source %d, device %08x&quot;</span>, inputSource, device);</span><br><span class="line">    <span class="keyword">return</span> device;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数会根据给进来的音频源参数，选择合适并且可用的音频设备，由此，就完成了从Android App层面音频源(<code>AudioSource</code>)到Audio Hal(<code>audio_policy.conf</code>)的调用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;初始化&quot;&gt;&lt;a href=&quot;#初始化&quot; class=&quot;headerlink&quot; title=&quot;初始化&quot;&gt;&lt;/a&gt;初始化&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/../../out/source/_posts/Android%20%E9%9F%B3%E9%A2%91%E6</summary>
      
    
    
    
    <category term="Android" scheme="http://nevermindzzt.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="http://nevermindzzt.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>letter-shell代理函数解析</title>
    <link href="http://nevermindzzt.github.io/2020/04/17/letter-shell%E4%BB%A3%E7%90%86%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90/"/>
    <id>http://nevermindzzt.github.io/2020/04/17/letter-shell%E4%BB%A3%E7%90%86%E5%87%BD%E6%95%B0%E8%A7%A3%E6%9E%90/</id>
    <published>2020-04-17T00:32:45.000Z</published>
    <updated>2020-07-07T04:56:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://github.com/NevermindZZT/letter-shell">letter shell</a>默认支持整形，字符，字符串参数的自动解析，我一直以为，浮点型的参数也是可以支持的，结果前几天发现，浮点型参数只在某些特定情况下可以使用(仅当浮点型参数为函数的最后一个参数时)，为此，我尝试了一种新的方式，从而引出了代理函数和代理参数解析的概念，可以实现任意类型参数的解析</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>如果你需要导出一个命令到shell，但是函数又有shell原生不支持的数据类型，比如说<code>void test(int a, float b, int c, float d)</code>，那么要怎么办呢</p><p>最简单的，你可能会重新定义一个函数<code>void testWarpper(int a, int b, int c, int d)</code>，在这个函数里面对参数进行转换，调用<code>test</code>，然后导出<code>testWarpper</code>作为命令</p><p>这就是所谓代理函数的概念，letter shell的代理函数就是基于此，只不过通过宏，简化了代理函数的定义，代理函数宏定义如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief shell 代理函数名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     SHELL_AGENCY_FUNC_NAME(_func)   agency##_func</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief shell代理函数定义</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param _func 被代理的函数</span></span><br><span class="line"><span class="comment"> * @param ... 代理参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     SHELL_AGENCY_FUNC(_func, ...) \</span></span><br><span class="line"><span class="meta">            void SHELL_AGENCY_FUNC_NAME(_func)(int p1, int p2, int p3, int p4, int p5, int p6, int p7) \</span></span><br><span class="line"><span class="meta">            &#123; _func(__VA_ARGS__); &#125;</span></span><br></pre></td></tr></table></figure><p>定义了代理函数，我们需要在代理函数里对参数进行处理，我称之为代理参数解析，参考letter shell的代理函数宏定义，shell会将终端输入的参数，解析成shell支持的基本参数数据，按顺序以<code>p1~p7</code>的参数传递进来，使用者需要定义代理参数解析器，可以为一个函数，或者宏，或者只是简单的数据处理，通过代理参数解析器，将<code>p1~p7</code>中对应的参数，转换成原函数需要的数据类型</p><p>letter shell默认实现了浮点参数的代理参数解析器，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief shell float型参数转换</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>     SHELL_PARAM_FLOAT(x)            (*(float *)(&amp;x))</span></span><br></pre></td></tr></table></figure><p>有了代理函数和对应的代理参数解析器，就可以将代理函数导出到命令，从而可以实现任意参数类型的解析，letter shell提供了一个宏，可以一步定义代理函数和导出命令，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief shell 代理命令定义</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param _attr 命令属性</span></span><br><span class="line"><span class="comment"> * @param _name 命令名</span></span><br><span class="line"><span class="comment"> * @param _func 命令函数</span></span><br><span class="line"><span class="comment"> * @param _desc 命令描述</span></span><br><span class="line"><span class="comment"> * @param ... 代理参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHELL_EXPORT_CMD_AGENCY(_attr, _name, _func, _desc, ...) \</span></span><br><span class="line"><span class="meta">        SHELL_AGENCY_FUNC(_func, ##__VA_ARGS__) \</span></span><br><span class="line"><span class="meta">        SHELL_EXPORT_CMD(_attr, _name, SHELL_AGENCY_FUNC_NAME(_func), _desc)</span></span><br></pre></td></tr></table></figure><p>代理函数命令导出宏前4个参数和常规形式的命令导出一致，之后的参数即传递至目标函数的参数，对于shell直接支持的参数类型，直接写对应的<code>px(x为1~7)</code>即可，代理参数类型则需要使用代理参数解析器，如<code>SHELL_PARAM_FLOAT(p2)</code></p><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>下面通过几个例子详细说明letter shell中代理函数的使用</p><h3 id="浮点参数"><a href="#浮点参数" class="headerlink" title="浮点参数"></a>浮点参数</h3><p>一个包含多个浮点参数的函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">float</span> b, <span class="type">int</span> c, <span class="type">float</span> d)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %f, c = %d, d = %f \r\n&quot;</span>, a, b, c, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用letter shell默认实现的浮点参数解析器定义代理函数以及导出命令：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHELL_EXPORT_CMD_AGENCY(SHELL_CMD_TYPE(SHELL_TYPE_CMD_FUNC),</span><br><span class="line">test, test, test <span class="type">float</span> param,</span><br><span class="line">p1, SHELL_PARAM_FLOAT(p2), p3, SHELL_PARAM_FLOAT(p4));</span><br></pre></td></tr></table></figure><p>参数中，第一个参数和第三个参数时letter shell原生支持的参数类型，不需要代理解析，所以直接写<code>p1</code>和<code>p3</code>即可，而第二个和第四个参数是浮点型的数据，这里使用letter shell默认实现的浮点参数代理解析器对参数进行代理解析，写入<code>SHELL_PARAM_FLOAT(p2)</code>和<code>SHELL_PARAM_FLOAT(p4))</code></p><p>在命令行调用结果如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">letter:/$ <span class="built_in">test</span> 12 12.5 854 7895.4</span><br><span class="line">a = 12, b = 12.500000, c = 854, d = 7895.399902</span><br><span class="line">Return: 34, 0x00000022</span><br></pre></td></tr></table></figure><h3 id="结构体参数"><a href="#结构体参数" class="headerlink" title="结构体参数"></a>结构体参数</h3><p>一个包含结构体参数的函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> *b;</span><br><span class="line">&#125; Test;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">char</span> *name, Test *test)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name: %s, a: %d, b: %s\r\n&quot;</span>, name, test-&gt;a, test-&gt;b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们直接使用C99复合文字的特性，作为代理参数解析器，可以导出命令如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SHELL_EXPORT_CMD_AGENCY(SHELL_CMD_TYPE(SHELL_TYPE_CMD_FUNC),</span><br><span class="line">test, test, test <span class="keyword">struct</span>,</span><br><span class="line">(<span class="type">char</span> *)p1, &amp;(Test)&#123;p2, (<span class="type">char</span> *)p3&#125;);</span><br></pre></td></tr></table></figure><p>导出的命令需要三个参数，第一个参数传递给<code>test</code>函数的形参<code>name</code>，第二个参数和第三个参数作为结构体<code>Test</code>的成员，通过复合文字特性的代理参数解析，生成结构体传递给<code>test</code>函数的形参<code>test</code></p><p>在命令行调用结果如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">letter:/$ <span class="built_in">test</span> hello 123 <span class="built_in">test</span></span><br><span class="line">name: hello, a: 123, b: <span class="built_in">test</span></span><br><span class="line">Return: 30, 0x0000001e</span><br></pre></td></tr></table></figure><p>对于稍微复杂的结构体参数，还可以结合<a href="https://github.com/NevermindZZT/cson">cson</a>，以字符串的形式将json数据传入，然后使用cson将字符串代理解析成结构体参数</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>原理上来说，letter shell的代理函数并不复杂，本质上，就只是重新定义了一个函数，实现参数的转化，letter shell结合宏定义，简化了真个代理函数的定义流程，将函数定义和命令导出结合到一条宏，并和原先的宏定义保持类似的结构</p><p>总而言之，借助代理函数和代理参数解析，你可以使用letter shell实现任意参数的传递，将任意形式的函数作为shell命令导出</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/NevermindZZT/letter-shell&quot;&gt;letter shell&lt;/a</summary>
      
    
    
    
    <category term="letter shell" scheme="http://nevermindzzt.github.io/categories/letter-shell/"/>
    
    
    <category term="嵌入式 shell C" scheme="http://nevermindzzt.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F-shell-C/"/>
    
  </entry>
  
  <entry>
    <title>Letter shell 3.0 全新出发</title>
    <link href="http://nevermindzzt.github.io/2020/01/19/Letter%20shell%203.0%E5%85%A8%E6%96%B0%E5%87%BA%E5%8F%91/"/>
    <id>http://nevermindzzt.github.io/2020/01/19/Letter%20shell%203.0%E5%85%A8%E6%96%B0%E5%87%BA%E5%8F%91/</id>
    <published>2020-01-18T16:00:00.000Z</published>
    <updated>2020-07-07T04:56:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>从我一开始写<a href="https://github.com/NevermindZZT/letter-shell">letter shell</a>已经一年多了，从1.x版本shell只能做命令解析，到2.x版本加入快捷键等功能，letter shell功能慢慢变多，但是体积也越来越大，似乎违背了我一开始只是想做一个超小型调试工具的想法，因此，我重新实现了letter shell 3.0，作为一个功能更加强大的版本，原先的2.x版本保留原有功能，继续维护。</p><h2 id="3-0改变了什么"><a href="#3-0改变了什么" class="headerlink" title="3.0改变了什么"></a>3.0改变了什么</h2><p>letter shell 3.0保留了2.x版本的所有功能，此次新增加了用户管理，权限管理，加入了对main函数形式和普通C函数命令的同时支持，加强了快捷键功能，此外，后续还会增加文件系统支持等其他功能</p><h2 id="移植"><a href="#移植" class="headerlink" title="移植"></a>移植</h2><p>letter shell 3.0在一直这一块基本保留了2.x的结构，原先使用2.x版本的如果想迁移，只需要简单的修改即可</p><ol><li><p>定义shell</p><p> 首先定义shell对象，3.0版本修改了结构体命名，从2.x版本迁移的话需要注意</p><p> 新建一个shell_port.c文件，定义shell</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Shell shell;</span><br></pre></td></tr></table></figure></li><li><p>申请内存</p><p> letter shell需要申请一片内存作为数据缓冲，申请内存大小取决于你希望命令行输入的最大长度和历史命令记录的数量，具体计算方式为<code>(历史命令最大数量 + 1) * 命令行输入最大长度</code></p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buffer[<span class="number">512</span>];</span><br></pre></td></tr></table></figure></li><li><p>实现字符接收函数</p><p> 若使用<code>shellTask</code>，需要实现字符接收函数函数原型为<code>typedef signed char (*shellRead)(char *);</code>，该函数有一个输出参数，表示接收到的字符，返回值为0表示接收到了数据，-1表示没有接收到数据</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">signed</span> <span class="type">char</span> <span class="title function_">shellRead</span><span class="params">(<span class="type">char</span> *data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> serialReceive(&amp;debugSerial, (<span class="type">uint8_t</span> *)data, <span class="number">1</span>, <span class="number">0</span>) == <span class="number">1</span> ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 若不使用<code>shellTask</code>，可不实现读函数</p></li><li><p>实现写字符发送函数</p><p> 需要实现的字符发送函数原型为<code>typedef void (*shellWrite)(const char);</code>，该函数有一个输入参数，表示需要发送的字符，无返回值</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">shellWrite</span><span class="params">(<span class="type">const</span> <span class="type">char</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    serialTransmit(&amp;debugSerial, (<span class="type">uint8_t</span> *)&amp;data, <span class="number">1</span>, <span class="number">0xFF</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>初始化shell</p><p> 对shell进行初始化</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shell.read = shellRead;</span><br><span class="line">shell.write = shellWrite;</span><br><span class="line">shellInit(&amp;shell, buffer, <span class="number">512</span>);</span><br></pre></td></tr></table></figure></li><li><p>建立shell任务</p><p> 对于使用操作系统的情况，需要建立<code>shellTask</code>任务，任务参数为定义的shell对象，任务栈大小可以根据需要分配，请以shell可能运行的函数所需要的最大栈为准，注意，请确认shell_cfg.h文件中的宏<code>SHELL_TASK_WHILE</code>打开</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OSTaskCreate(shellTask, &amp;shell, ...);</span><br></pre></td></tr></table></figure><p> 对于不使用操作系统的情况，需要在主循环中调用<code>shellTask</code>，注意，此时shell_cfg.h文件中的宏<code>SHELL_TASK_WHILE</code>应该是关闭状态</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    shellTask(&amp;shell);</span><br><span class="line">    <span class="comment">// 其他任务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 其他情况，也可以不使用<code>shellTask</code>，但是需要在接收到字符时，主动调用<code>shellHandler</code></p></li></ol><h2 id="命令声明"><a href="#命令声明" class="headerlink" title="命令声明"></a>命令声明</h2><p>letter shell支持main函数命令，普通C函数命令，用户声明，变量声明，快捷键声明，通过宏<code>SHELL_EXPORT_XXX</code>导出</p><h3 id="main形式函数声明"><a href="#main形式函数声明" class="headerlink" title="main形式函数声明"></a>main形式函数声明</h3><p>main函数形式的函数原型为<code>int func(int argc, char *argv[])</code>，函数的所有参数都以字符串数组的形式传入<code>argv</code>参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func_main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *agrv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%dparameter(s)\r\n&quot;</span>, argc);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> i = <span class="number">1</span>; i &lt; argc; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\r\n&quot;</span>, argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">SHELL_EXPORT_CMD(SHELL_CMD_PERMISSION(<span class="number">0</span>)|SHELL_CMD_TYPE(SHELL_TYPE_CMD_MAIN), func, func_main, this is a main like function);</span><br></pre></td></tr></table></figure><p>其中，<code>SHELL_CMD_PERMISSION(0)</code>表示这个命令的权限为0，即无权限需要，所有用户都可以调用，<code>SHELL_CMD_TYPE(SHELL_TYPE_CMD_MAIN)</code>表示这个是一个main函数形式的命令，<code>func</code>表示命令名，即在终端调用的名字，<code>func_main</code>即函数名，最后一个参数是对这个命令的描述，可通过<code>help</code>明林查看</p><p>在终端中调用这个命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">letter:/$ func <span class="string">&quot;hello world&quot;</span></span><br><span class="line">2 parameter(s)</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><h3 id="普通C函数命令声明"><a href="#普通C函数命令声明" class="headerlink" title="普通C函数命令声明"></a>普通C函数命令声明</h3><p>普通C函数形式的命令是通过letter shell对参数进行解析，自动转换参数，然后执行函数，支持整数，浮点数，字符和字符串参数，支持变量作为参数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span> i, <span class="type">char</span> ch, <span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input int: %d, char: %c, string: %s\r\n&quot;</span>, i, ch, str);</span><br><span class="line">&#125;</span><br><span class="line">SHELL_EXPORT_CMD(SHELL_CMD_PERMISSION(<span class="number">0</span>)|SHELL_CMD_TYPE(SHELL_TYPE_CMD_FUNC), func, func, this is a c like function);</span><br></pre></td></tr></table></figure><p>其中，<code>SHELL_CMD_TYPE(SHELL_TYPE_CMD_FUNC)</code>表示这是一个普通C函数形式的命令</p><p>在终端中调用这个命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">letter:/$ func 666 <span class="string">&#x27;A&#x27;</span> <span class="string">&quot;hello world&quot;</span></span><br><span class="line">input int: 666, char: A, string: hello world</span><br></pre></td></tr></table></figure><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>letter shell支持支持定义整数，浮点数，指针形式的变量，定义的变量可以通过<code>setVar</code>命令进行修改，可以以<code>$&#123;var&#125;</code>的形式作为参数传进命令中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> testVar = <span class="number">256</span>;</span><br><span class="line">SHELL_CMD_VAR(SHELL_CMD_PERMISSION(<span class="number">0</span>)|SHELL_CMD_TYPE(SHELL_TYPE_VAR_INT), testVar, &amp;testVar, var <span class="keyword">for</span> test);</span><br></pre></td></tr></table></figure><p>其中，<code>SHELL_CMD_TYPE(SHELL_TYPE_VAR_INT)</code>表示这是一个<code>int</code>类型的变量，变量不是指针类型时，需要对变量取引用<code>&amp;testVar</code>，相应的，支持的变量类型和类型定义宏如下：</p><table><thead><tr><th>类型</th><th>宏</th></tr></thead><tbody><tr><td>char</td><td>SHELL_TYPE_VAR_CHAR</td></tr><tr><td>short</td><td>SHELL_TYPE_VAR_SHORT</td></tr><tr><td>int</td><td>SHELL_TYPE_VAR_INT</td></tr><tr><td>float</td><td>SHELL_TYPE_VAR_FLOAT</td></tr><tr><td>常量</td><td>SHELL_TYPE_VAL</td></tr></tbody></table><p>在终端中查看变量</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">letter:/$ testVar</span><br><span class="line">testVar = 256, 0x00000100</span><br></pre></td></tr></table></figure><p>修改变量</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">letter:/$ setVar testVar 65536</span><br><span class="line">testVar = 65536, 0x00010000</span><br></pre></td></tr></table></figure><p>变量作为命令参数</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">letter:/$ func &amp;testVar <span class="string">&#x27;A&#x27;</span> <span class="string">&quot;hello world&quot;</span></span><br><span class="line">input int: 256, char: A, string: hello world</span><br></pre></td></tr></table></figure><h3 id="用户声明"><a href="#用户声明" class="headerlink" title="用户声明"></a>用户声明</h3><p>letter shell 3.0版本新加入了用户管理，支持像定义命令一样定义用户</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHELL_EXPORT_USER(SHELL_CMD_PERMISSION(<span class="number">0xFF</span>), root, admin, root user);</span><br></pre></td></tr></table></figure><p>其中<code>SHELL_CMD_PERMISSION(0xFF)</code>表示这个用户的权限，同命令的权限对应，当命令权限为0，或者用户权限同命令权限按位与不为0时，表明这个用户拥有该命令的权限，可以查看，执行，<code>root</code>表示用户名称，<code>admin</code>表示用户密码，留空时表示这个用户不需要设置密码，最后一个参数时对用户的描述</p><p>在终端切换用户</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">letter:/$ root</span><br><span class="line"></span><br><span class="line">Please input password:admin</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>对于设置了密码的用户，也可以通过执行<code>&#123;user&#125; &#123;password&#125;</code>直接切换用户并校验密码</p><h3 id="按键声明"><a href="#按键声明" class="headerlink" title="按键声明"></a>按键声明</h3><p>letter shell 3.0增强了2.x版本的快捷键功能，最多支持四个字节键的快捷键</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHELL_EXPORT_KEY(SHELL_CMD_PERMISSION(<span class="number">0</span>)|SHELL_CMD_ENABLE_UNCHECKED,</span><br><span class="line"><span class="number">0x1B5B337E</span>, shellDelete, delete);</span><br></pre></td></tr></table></figure><p>其中，<code>0x1B5B337E</code>表示这个按键的键值，即按下按键之后，终端会依次发送0x1B, 0x5B, 0x33, 0x7E四个字节，如果按键键值不足四个字节，以大端模式表示，低字节补0，比如tab键，键值为<code>0x0B000000</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;从我一开始写&lt;a href=&quot;https://github.com/NevermindZZT/letter-shell&quot;&gt;letter sh</summary>
      
    
    
    
    <category term="letter shell" scheme="http://nevermindzzt.github.io/categories/letter-shell/"/>
    
    
    <category term="嵌入式" scheme="http://nevermindzzt.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="STM32" scheme="http://nevermindzzt.github.io/tags/STM32/"/>
    
    <category term="C" scheme="http://nevermindzzt.github.io/tags/C/"/>
    
    <category term="shell" scheme="http://nevermindzzt.github.io/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Android 技巧总结</title>
    <link href="http://nevermindzzt.github.io/2019/10/21/Andorid%20%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"/>
    <id>http://nevermindzzt.github.io/2019/10/21/Andorid%20%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/</id>
    <published>2019-10-20T16:00:00.000Z</published>
    <updated>2020-07-07T04:56:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ADB"><a href="#ADB" class="headerlink" title="ADB"></a>ADB</h2><ul><li><p>隐藏虚拟键及顶部状态栏：</p><p>adb shell settings put global policy_control immersive.full&#x3D;*</p></li><li><p>隐藏顶部状态栏（底部虚拟键会显示）：</p><p>adb shell settings put global policy_control immersive.status&#x3D;*</p></li><li><p>隐藏虚拟键（顶部状态栏会显示）：</p><p>adb shell settings put global policy_control immersive.navigation&#x3D;*</p></li><li><p>恢复原来的设置：</p><p>adb shell settings put global policy_control null</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ADB&quot;&gt;&lt;a href=&quot;#ADB&quot; class=&quot;headerlink&quot; title=&quot;ADB&quot;&gt;&lt;/a&gt;ADB&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;隐藏虚拟键及顶部状态栏：&lt;/p&gt;
&lt;p&gt;adb shell settings put global policy_</summary>
      
    
    
    
    <category term="Android" scheme="http://nevermindzzt.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="http://nevermindzzt.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>在C语言上优雅地使用json</title>
    <link href="http://nevermindzzt.github.io/2019/08/29/%E5%9C%A8C%E8%AF%AD%E8%A8%80%E4%B8%8A%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8json/"/>
    <id>http://nevermindzzt.github.io/2019/08/29/%E5%9C%A8C%E8%AF%AD%E8%A8%80%E4%B8%8A%E4%BC%98%E9%9B%85%E5%9C%B0%E4%BD%BF%E7%94%A8json/</id>
    <published>2019-08-28T16:00:00.000Z</published>
    <updated>2020-07-07T04:56:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>json是目前最为流行的文本数据传输格式，特别是在网络通信上广泛应用，随着物联网的兴起，在嵌入式设备上，也需要开始使用json进行数据传输，那么，如何快速简洁地用C语言进行json的序列化和反序列化呢</p><span id="more"></span><p>当前，应用最广泛的C语言json解析库当属<a href="https://github.com/kbranigan/cJSON">cJSON</a>，但是，使用cJSON读json进行序列化和反序列化，需要根据key一个一个进行处理，会导致代码冗余，逻辑性不强，哪有没有更好的方法呢</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在Android平台，一般会使用<a href="https://github.com/google/gson">gson</a>等工具解析json，这些工具将json直接映射成对象，在C语言上使用对象的概念，我们需要借助结构体，然而，最大的问题在于，C语言没有高级语言具有的反射机制，直接从json映射到结构体对象几乎是不可能的</p><p>怎么解决呢，既然C语言没有反射机制，那么我们可以自己定义一套类似于反射的机制，这里我将其称之为结构体数据模型，在数据模型中，我们需要准确地描述结构体的特征，包括结构体各成员的名称，类型，在结构体中的偏移，有了这些，我们可以在解析josn的时候，将解析得到的数据直接写入到对应的内存里面去，或者是在序列化的时候，直接从对应的内存中读取数据，进行处理</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p><a href="https://github.com/NevermindZZT/cson">CSON</a>正是采用上面说到的思路，使用数据模型对结构体进行描述，然后基于cJSON，根据数据模型进行解析，将解析得到的数据直接写入到对应的内存区域，从而实现从json到结构体对象的映射</p><p>CSON最基本的数据模型定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cson_model</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    CsonType type;                      <span class="comment">/**&lt; 数据类型 */</span></span><br><span class="line">    <span class="type">char</span> *key;                          <span class="comment">/**&lt; 元素键值 */</span></span><br><span class="line">    <span class="type">short</span> offset;                       <span class="comment">/**&lt; 元素偏移 */</span></span><br><span class="line">&#125; CsonModel;</span><br></pre></td></tr></table></figure><p>通过<code>type</code>描述结构体成员的数据类型，<code>key</code>描述该成员在json中对应的字段，<code>offset</code>描述该结构体成员在结构体中的偏移，CSON在解析json的时候，根据<code>type</code>调用相应的cJSON API并传递<code>key</code>作为参数，得到解析出的数据，然后根据<code>offset</code>将数据写入到对应的内存空间</p><p>比如说这样一个结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">project</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该结构体包含两个成员，对于成员<code>id</code>，我们使用数据模型对其进行描述<code>&#123;.type=CSON_TYPE_CHAR, key=&quot;id&quot;, offset=0&#125;</code>，对于结构体的每个成员，都进行数据模型的定义，就可以得到一个完整的结构体数据模型，CSON会根据这个模型，进行解析</p><p>因为是通过直接写内存的方式，所以在写不同类型的量到内存中时，会多次用到强制转型，导致CSON中赋值的代码都类似于<code>*(int *)((int)obj + model[i].offset) = (int)csonDecodeNumber(json, model[i].key);</code></p><p>当然，上面说到的数据模型，只适用于基本数据类型的数据，对于子结构体，链表，数组等，需要对数据模型的定义进行扩充，有兴趣的朋友可以直接阅读CSON源码</p><h2 id="CSON使用实例"><a href="#CSON使用实例" class="headerlink" title="CSON使用实例"></a>CSON使用实例</h2><h3 id="声明结构体"><a href="#声明结构体" class="headerlink" title="声明结构体"></a>声明结构体</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 项目结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">project</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> *name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 仓库结构体 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hub</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">char</span> *user;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">project</span> *<span class="title">cson</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="定义数据模型"><a href="#定义数据模型" class="headerlink" title="定义数据模型"></a>定义数据模型</h3><p>对每一个需要使用cson的结构体，都需要定义相对应的数据模型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 项目结构体数据模型 */</span></span><br><span class="line">CsonModel projectModel[] =</span><br><span class="line">&#123;</span><br><span class="line">    CSON_MODEL_OBJ(<span class="keyword">struct</span> project),</span><br><span class="line">    CSON_MODEL_INT(<span class="keyword">struct</span> project, id),</span><br><span class="line">    CSON_MODEL_STRING(<span class="keyword">struct</span> project, name),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 仓库结构体数据模型 */</span></span><br><span class="line">CsonModel hubModel[] =</span><br><span class="line">&#123;</span><br><span class="line">    CSON_MODEL_OBJ(<span class="keyword">struct</span> hub),</span><br><span class="line">    CSON_MODEL_INT(<span class="keyword">struct</span> hub, id),</span><br><span class="line">    CSON_MODEL_STRING(<span class="keyword">struct</span> hub, user),</span><br><span class="line">    CSON_MODEL_STRUCT(<span class="keyword">struct</span> hub, cson, projectModel, <span class="keyword">sizeof</span>(projectModel)/<span class="keyword">sizeof</span>(CsonModel))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用CSON解析"><a href="#使用CSON解析" class="headerlink" title="使用CSON解析"></a>使用CSON解析</h3><p>只需要定义好数据模型，就可以使用CSON读json进行序列化和反序列化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">csonDemo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *jsonDemo = <span class="string">&quot;&#123;\&quot;id\&quot;: 1, \&quot;user\&quot;: \&quot;Letter\&quot;, \&quot;cson\&quot;: &#123;\&quot;id\&quot;: 2, \&quot;name\&quot;: \&quot;cson\&quot;&#125;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 解析json */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">hub</span> *<span class="title">pHub</span> =</span> csonDecode(jsonDemo, hubModel, <span class="keyword">sizeof</span>(hubModel)/<span class="keyword">sizeof</span>(CsonModel));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hub: id: %d, user: %s, project id: %d, project name: %s\r\n&quot;</span>,</span><br><span class="line">        pHub-&gt;id, pHub-&gt;user, pHub-&gt;cson-&gt;id, pHub-&gt;cson-&gt;name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 序列化对象 */</span></span><br><span class="line">    <span class="type">char</span> *formatJson = csonEncodeFormatted(pHub, hubModel, <span class="keyword">sizeof</span>(hubModel)/<span class="keyword">sizeof</span>(CsonModel));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;format json: %s\r\n&quot;</span>, formatJson);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 释放结构体对象 */</span></span><br><span class="line">    csonFree(pHub, hubModel, <span class="keyword">sizeof</span>(hubModel)/<span class="keyword">sizeof</span>(CsonModel));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 释放序列化生成的json字符串 */</span></span><br><span class="line">    csonFreeJson(formatJson);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hub: id: 1, user: Letter, project id: 2, project name: cson</span><br><span class="line">format json: &#123;</span><br><span class="line">        &quot;id&quot;:   1,</span><br><span class="line">        &quot;user&quot;: &quot;Letter&quot;,</span><br><span class="line">        &quot;cson&quot;: &#123;</span><br><span class="line">                &quot;id&quot;:   2,</span><br><span class="line">                &quot;name&quot;: &quot;cson&quot;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，无论是解析json，还是序列化结构体到json，在使用CSON的情况下，都只需要一行代码就可以解决，同样的操作，在使用原生cJSON的情况下，你可能需要多次判断，解析元素</p><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p>CSON项目已经发布到Github，<a href="https://github.com/NevermindZZT/cson">点击查看</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;json是目前最为流行的文本数据传输格式，特别是在网络通信上广泛应用，随着物联网的兴起，在嵌入式设备上，也需要开始使用json进行数据传输，那么，如何快速简洁地用C语言进行json的序列化和反序列化呢&lt;/p&gt;</summary>
    
    
    
    <category term="嵌入式" scheme="http://nevermindzzt.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
    <category term="嵌入式" scheme="http://nevermindzzt.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="STM32" scheme="http://nevermindzzt.github.io/tags/STM32/"/>
    
    <category term="C" scheme="http://nevermindzzt.github.io/tags/C/"/>
    
    <category term="json" scheme="http://nevermindzzt.github.io/tags/json/"/>
    
  </entry>
  
  <entry>
    <title>Android 自定义颜色选择器的实现</title>
    <link href="http://nevermindzzt.github.io/2019/07/19/Android%20%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A2%9C%E8%89%B2%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://nevermindzzt.github.io/2019/07/19/Android%20%E8%87%AA%E5%AE%9A%E4%B9%89%E9%A2%9C%E8%89%B2%E9%80%89%E6%8B%A9%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2019-07-18T16:00:00.000Z</published>
    <updated>2020-07-07T04:56:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>某日，突然产生想法，给我自己做的纪念日的APP加一个主题色的功能，那自然就需要用到颜色选择器了，在网上搜索了一圈，没找到自己想要的，于是干脆就自己做一个吧。刚好最近也在研究Kotlin，于是就拿Kotlin写了一个简单的颜色选择器</p><span id="more"></span><p>先上效果图：</p><p><img src="https://s1.ax1x.com/2020/04/10/GIXGRJ.png" alt="img_android_color_picker.png"></p><h2 id="颜色盘"><a href="#颜色盘" class="headerlink" title="颜色盘"></a>颜色盘</h2><p>颜色选择器最基本的元素就是单个的颜色控件了，简单的颜色控件设计只需要一个单色的圆加上边框就行，就直接用<code>View</code>画了</p><p>首先定义好<code>ColorPane</code>所需要的自定义属性，包括颜色属性，边框颜色和边框宽度</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span> = <span class="string">&quot;ColorPane&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;color&quot;</span> <span class="attr">format</span>=<span class="string">&quot;color&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;strokeColor&quot;</span> <span class="attr">format</span>=<span class="string">&quot;color&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;strokeWidth&quot;</span> <span class="attr">format</span>=<span class="string">&quot;dimension&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后新建<code>ColorPane</code>类继承自<code>View</code>，在构造器中，处理从xml中解析的相关属性</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> attrArray = context.obtainStyledAttributes(attrs, R.styleable.ColorPane)</span><br><span class="line"></span><br><span class="line">    color = attrArray.getColor(R.styleable.ColorPane_color, <span class="number">0</span>)</span><br><span class="line">    strokeColor = attrArray.getColor(R.styleable.ColorPane_strokeColor, <span class="number">0</span>)</span><br><span class="line">    strokeWidth = attrArray.getDimension(R.styleable.ColorPane_strokeWidth, <span class="number">0f</span>)</span><br><span class="line"></span><br><span class="line">    attrArray.recycle()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后重写父类的<code>onDraw</code>方法，在画布上画出一个实心圆和边框，<code>onDraw</code>方法如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDraw</span><span class="params">(canvas: <span class="type">Canvas</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onDraw(canvas)</span><br><span class="line"></span><br><span class="line">    paint.color = color</span><br><span class="line">    paint.style = Paint.Style.FILL</span><br><span class="line"></span><br><span class="line">    canvas?.drawCircle(width.toFloat() / <span class="number">2</span>, height.toFloat() / <span class="number">2</span>,</span><br><span class="line">        (min(width, height) / <span class="number">2</span> - <span class="keyword">if</span> (strokeWidth &gt; <span class="number">0</span>) <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span>).toFloat(), paint)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (strokeWidth &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        paint.color = strokeColor</span><br><span class="line">        paint.style = Paint.Style.STROKE</span><br><span class="line">        paint.strokeWidth = strokeWidth</span><br><span class="line">        canvas?.drawCircle(width.toFloat() / <span class="number">2</span>, height.toFloat() / <span class="number">2</span>,</span><br><span class="line">            (min(width, height) / <span class="number">2</span>).toFloat() - (strokeWidth) / <span class="number">2</span>, paint)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (checked) &#123;</span><br><span class="line">        <span class="keyword">val</span> bright = (color.and(<span class="number">0x00FF0000</span>).ushr(<span class="number">16</span>) * <span class="number">0.3</span></span><br><span class="line">                + color.and(<span class="number">0x0000FF00</span>).ushr(<span class="number">8</span>) * <span class="number">0.6</span></span><br><span class="line">                + color.and(<span class="number">0x000000FF</span>) * <span class="number">0.1</span>)</span><br><span class="line">        <span class="keyword">if</span> (bright &gt; <span class="number">0x80</span> || color.toLong().and(<span class="number">0xFF000000</span>).ushr(<span class="number">24</span>) &lt; <span class="number">0x20</span>) &#123;</span><br><span class="line">            paint.color = Color.BLACK</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            paint.color = Color.WHITE</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> lineWidth = height.toFloat() / <span class="number">20</span></span><br><span class="line">        <span class="keyword">val</span> offsetX = -width.toFloat() / <span class="number">32</span></span><br><span class="line">        <span class="keyword">val</span> offsetY = height.toFloat() / <span class="number">8</span></span><br><span class="line">        paint.style = Paint.Style.STROKE</span><br><span class="line">        paint.strokeWidth = lineWidth</span><br><span class="line">        canvas?.drawLine(width.toFloat() / <span class="number">3</span> + offsetX, height.toFloat() / <span class="number">3</span> + offsetY,</span><br><span class="line">            width.toFloat() / <span class="number">2</span> + lineWidth / <span class="number">2.828f</span> + offsetX,</span><br><span class="line">            width.toFloat() / <span class="number">2</span> + lineWidth / <span class="number">2.828f</span> + offsetY, paint)</span><br><span class="line">        canvas?.drawLine(width.toFloat() / <span class="number">2</span> + offsetX, height.toFloat() / <span class="number">2</span> + offsetY,</span><br><span class="line">            width.toFloat() / <span class="number">4</span> * <span class="number">3</span> + offsetX, width.toFloat() / <span class="number">4</span> + offsetY, paint)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，通过对<code>checked</code>的判断，以确定当前控件是否被选中，如果被选中，计算当前颜色的深度，然后在画布中绘制一个勾</p><h2 id="颜色选择视图"><a href="#颜色选择视图" class="headerlink" title="颜色选择视图"></a>颜色选择视图</h2><p>颜色选择器视图可以使用<code>GridView</code>实现，将<code>ColorPane</code>作为<code>GridView</code>的子项，同样的，首先自定义一些属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">declare-styleable</span> <span class="attr">name</span>=<span class="string">&quot;ColorPickerView&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;colorResource&quot;</span> <span class="attr">format</span>=<span class="string">&quot;reference&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;colorPaneSize&quot;</span> <span class="attr">format</span>=<span class="string">&quot;dimension&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;colorPaneStroke&quot;</span> <span class="attr">format</span>=<span class="string">&quot;color&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;horizontalSpacing&quot;</span> <span class="attr">format</span>=<span class="string">&quot;dimension&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;verticalSpacing&quot;</span> <span class="attr">format</span>=<span class="string">&quot;dimension&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">attr</span> <span class="attr">name</span>=<span class="string">&quot;numColumns&quot;</span> <span class="attr">format</span>=<span class="string">&quot;integer&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">declare-styleable</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后定义视图的布局，这里我使用了一个<code>LinearLayout</code>作为父布局，实际上可以直接继承<code>GridView</code>实现的，如果直接继承<code>GridView</code>，则不需要这个布局文件，在加一层父布局的好处是可以添加一些额外的东西</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">GridView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/grid_view&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:numColumns</span>=<span class="string">&quot;auto_fit&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后新建<code>ColorPickerView</code>继承自<code>LinearLayout</code>，在构造器的初始化代码中进行初始化操作</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">init</span> &#123;</span><br><span class="line">    LayoutInflater.from(context).inflate(R.layout.layout_color_pick_view, <span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">    gridView = findViewById(R.id.grid_view)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> attrArray = context.obtainStyledAttributes(attrs, R.styleable.ColorPickerView)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> colorResourceId = attrArray.getResourceId(R.styleable.ColorPickerView_colorResource, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    colorPaneSize = attrArray.getDimension(R.styleable.ColorPickerView_colorPaneSize, <span class="number">0f</span>)</span><br><span class="line">    <span class="keyword">val</span> horizontalSpacing = attrArray.getDimension(R.styleable.ColorPickerView_horizontalSpacing, <span class="number">0f</span>)</span><br><span class="line">    <span class="keyword">val</span> verticalSpacing = attrArray.getDimension(R.styleable.ColorPickerView_verticalSpacing, <span class="number">0f</span>)</span><br><span class="line">    <span class="keyword">val</span> numColumns = attrArray.getInt(R.styleable.ColorPickerView_numColumns, <span class="number">0</span>)</span><br><span class="line">    colorPaneStroke = attrArray.getColor(R.styleable.ColorPickerView_colorPaneStroke, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    attrArray.recycle()</span><br><span class="line"></span><br><span class="line">    viewWidth = colorPaneSize * numColumns + horizontalSpacing * (numColumns - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (colorResourceId != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> colorStrings = context.resources.getStringArray(colorResourceId)</span><br><span class="line">        setColors(colorStrings)</span><br><span class="line">    &#125;</span><br><span class="line">    gridView?.onItemClickListener = <span class="keyword">this</span></span><br><span class="line">    gridView?.columnWidth = colorPaneSize.toInt()</span><br><span class="line">    gridView?.horizontalSpacing = horizontalSpacing.toInt()</span><br><span class="line">    gridView?.verticalSpacing = verticalSpacing.toInt()</span><br><span class="line">    <span class="keyword">if</span> (numColumns != <span class="number">0</span>) &#123;</span><br><span class="line">        gridView?.numColumns = numColumns</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们还需要实现一个适配器，提供给<code>GridView</code>，适配器的代码如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColorPickerListAdapter</span></span></span><br><span class="line">        (context: Context?, colors: ArrayList&lt;<span class="built_in">Int</span>&gt;, colorPaneSize: <span class="built_in">Int</span>, colorPaneStroke: <span class="built_in">Int</span>):</span><br><span class="line">        BaseAdapter() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> colorPaneList: MutableList&lt;ColorPane&gt; = mutableListOf()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> layoutParams: ViewGroup.LayoutParams =</span><br><span class="line">            <span class="keyword">if</span> (colorPaneSize == <span class="number">0</span>) &#123;</span><br><span class="line">                 ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,</span><br><span class="line">                        ViewGroup.LayoutParams.MATCH_PARENT)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ViewGroup.LayoutParams(colorPaneSize, colorPaneSize)</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (color <span class="keyword">in</span> colors) &#123;</span><br><span class="line">            <span class="keyword">val</span> colorPane = ColorPane(context!!)</span><br><span class="line">            colorPane.layoutParams = layoutParams</span><br><span class="line">            <span class="keyword">if</span> (colorPaneSize == <span class="number">0</span>) &#123;</span><br><span class="line">                colorPane.layoutParams = ViewGroup.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,</span><br><span class="line">                        ViewGroup.LayoutParams.WRAP_CONTENT)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                colorPane.layoutParams = ViewGroup.LayoutParams(colorPaneSize, colorPaneSize)</span><br><span class="line">            &#125;</span><br><span class="line">            colorPane.color = color</span><br><span class="line">            colorPane.strokeColor = colorPaneStroke</span><br><span class="line">            colorPane.strokeWidth = colorPaneSize.toFloat() / <span class="number">32</span></span><br><span class="line">            colorPaneList.add(colorPane)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItem</span><span class="params">(position: <span class="type">Int</span>)</span></span>: Any &#123;</span><br><span class="line">        <span class="keyword">return</span> colorPaneList[position]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> colorPaneList.size</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getView</span><span class="params">(position: <span class="type">Int</span>, convertView: <span class="type">View</span>?, parent: <span class="type">ViewGroup</span>?)</span></span>: View &#123;</span><br><span class="line">        <span class="keyword">return</span> colorPaneList[position]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemId</span><span class="params">(position: <span class="type">Int</span>)</span></span>: <span class="built_in">Long</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> position.toLong()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setItemColor</span><span class="params">(position: <span class="type">Int</span>, color: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        colorPaneList[position].color = color</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整的代码已同步至GitHub，可以<a href="https://github.com/NevermindZZT/ColorPickerDemo">前往GitHub查看</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;某日，突然产生想法，给我自己做的纪念日的APP加一个主题色的功能，那自然就需要用到颜色选择器了，在网上搜索了一圈，没找到自己想要的，于是干脆就自己做一个吧。刚好最近也在研究Kotlin，于是就拿Kotlin写了一个简单的颜色选择器&lt;/p&gt;</summary>
    
    
    
    <category term="Android" scheme="http://nevermindzzt.github.io/categories/Android/"/>
    
    
    <category term="Android" scheme="http://nevermindzzt.github.io/tags/Android/"/>
    
    <category term="Kotlin" scheme="http://nevermindzzt.github.io/tags/Kotlin/"/>
    
  </entry>
  
  <entry>
    <title>C语言复合文字的使用</title>
    <link href="http://nevermindzzt.github.io/2019/04/03/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E5%90%88%E6%96%87%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://nevermindzzt.github.io/2019/04/03/C%E8%AF%AD%E8%A8%80%E5%A4%8D%E5%90%88%E6%96%87%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2019-04-02T16:00:00.000Z</published>
    <updated>2020-07-07T04:56:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在一些高级语言中，有一种定义函数的方法，如Python中，可以定义<code>def func(arg1, arg2=2)</code>，这样可以定义函数形参的默认值，对于一些参数多，但是大多数参数基本不会变动的函数来说极其有用，那么，C语言是否也可以实现这样的功能呢</p><span id="more"></span><p>在C99的标准中，增加了一个新的特性，复合文字(composite literal)，很奇怪，这个特性是如此的好用，可是在我的身边几乎没有人知道这个东西</p><h1 id="复合文字应用"><a href="#复合文字应用" class="headerlink" title="复合文字应用"></a>复合文字应用</h1><h2 id="数组操作"><a href="#数组操作" class="headerlink" title="数组操作"></a>数组操作</h2><p>假设一个场景，有一个函数<code>void func(char *p, short size)</code>，你希望传递一个有数据的数组进去，那么可以这样</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="built_in">array</span>[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">func(<span class="built_in">array</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>你需要先创建数据，然后给数组里面的数据复制，最后将数据传递给函数，但是在应用了复合文字之后，你可以这样做</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func((<span class="type">char</span> [])&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>如何，数组像是一个基本数据类型的常量一样，被直接传递给了函数，当然，你也可以用这个机制，直接将一个数组作为函数的返回值返回</p><h2 id="结构体操作"><a href="#结构体操作" class="headerlink" title="结构体操作"></a>结构体操作</h2><p>使用复合文字特性操作数组，虽然看起来确实简化了一些操作，但是实际一看，好像对程序并没有多大提升，但是，当复合文字碰到结构体的时候，真正的作用就体现出来了</p><p>正如我在前言里说到的，使用复合文字结合结构体，我们可以实现参数默认值功能，特别是对于一些初始化操作，可以大大简化函数的使用。</p><p>以嵌入式中常用的串口为例，我们一般初始化串口时，要设置波特率，字长，起始位，校验，流控等，因而，我们可以要写一个参数表极长的函数，或者定义一个结构体，一个一个设置结构体成员的值，然而，一般情况下，上面说到的这些参数都是有一个默认值的，所以如果能定义一个函数，只需要给需要设置的参数，剩下的为默认值就好了，这就到复合文字大显身手的时候了</p><p>定义结构体(STM32 HAL库)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> BaudRate;</span><br><span class="line">    <span class="type">uint32_t</span> WordLength;</span><br><span class="line">    <span class="type">uint32_t</span> StopBits;</span><br><span class="line">    <span class="type">uint32_t</span> Parity;</span><br><span class="line">    <span class="type">uint32_t</span> Mode;</span><br><span class="line">    <span class="type">uint32_t</span> HwFlowCtl;</span><br><span class="line">    <span class="type">uint32_t</span> OverSampling;</span><br><span class="line">&#125;UART_InitTypeDef;</span><br></pre></td></tr></table></figure><p>定义初始化函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _SerialInit(<span class="type">char</span> uart, UART_InitTypeDef init)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/** 初始化操作 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般来说，利用复合文字，我们可以使用这种形式调用函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_SerialInit(<span class="number">1</span>, (UART_InitTypeDef)&#123;BaudRate=<span class="number">115200</span>, .WordLength=UART_WORDLENGTH_8B, <span class="comment">/** 其他参数 */</span>&#125;);</span><br></pre></td></tr></table></figure><p>好像还是没有事项参数默认值啊，不急，我们只差一个宏定义了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> serialInit(uart, ...) \</span></span><br><span class="line"><span class="meta">        _SerialInit( \</span></span><br><span class="line"><span class="meta">            uart, \</span></span><br><span class="line"><span class="meta">            (UART_InitTypeDef)&#123; \</span></span><br><span class="line"><span class="meta">                .BaudRate = 115200, \</span></span><br><span class="line"><span class="meta">                .WordLength = UART_WORDLENGTH_8B, \</span></span><br><span class="line"><span class="meta">                .StopBits = UART_STOPBITS_1, \</span></span><br><span class="line"><span class="meta">                .Parity = UART_PARITY_NONE, \</span></span><br><span class="line"><span class="meta">                .Mode = UART_MODE_TX_RX, \</span></span><br><span class="line"><span class="meta">                .HwFlowCtl = UART_HWCONTROL_NONE, \</span></span><br><span class="line"><span class="meta">                .OverSampling = UART_OVERSAMPLING_16, \</span></span><br><span class="line"><span class="meta">                ##__VA_ARGS__, \</span></span><br><span class="line"><span class="meta">            &#125;)</span></span><br></pre></td></tr></table></figure><p>好了，我们在这个宏中设置所有参数的默认值，我们调用的时候，就可以只设置我们需要设置的参数了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">serialInit(<span class="number">1</span>);                              <span class="comment">/** 所有参数使用默认值 */</span></span><br><span class="line">serialInit(<span class="number">1</span>, .BaudRate=<span class="number">19200</span>);             <span class="comment">/** 重设置波特率 */</span></span><br><span class="line">serialInit(<span class="number">1</span>, .BaueRate=<span class="number">19200</span>, .StopBits = UART_STOPBITS_2) <span class="comment">/** 重设波特率和停止位 */</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>C语言其实也一直在成长，每一次更新都会引入一些新的特性，这些特性无疑是为了更好的使用这门语言，所以即使了解一些新的特性，可以让我们写出更高效的代码</p><p>PS：突然萌生想法，可不可以利用这个特性实现类似C++, JAVA等语言中的函数重载</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在一些高级语言中，有一种定义函数的方法，如Python中，可以定义&lt;code&gt;def func(arg1, arg2=2)&lt;/code&gt;，这样可以定义函数形参的默认值，对于一些参数多，但是大多数参数基本不会变动的函数来说极其有用，那么，C语言是否也可以实现这样的功能呢&lt;/p&gt;</summary>
    
    
    
    <category term="C" scheme="http://nevermindzzt.github.io/categories/C/"/>
    
    
    <category term="C" scheme="http://nevermindzzt.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>使用VS Code打造完美的嵌入式IDE</title>
    <link href="http://nevermindzzt.github.io/2019/03/15/%E4%BD%BF%E7%94%A8VS%20Code%E6%89%93%E9%80%A0%E5%AE%8C%E7%BE%8E%E7%9A%84%E5%B5%8C%E5%85%A5%E5%BC%8FIDE/"/>
    <id>http://nevermindzzt.github.io/2019/03/15/%E4%BD%BF%E7%94%A8VS%20Code%E6%89%93%E9%80%A0%E5%AE%8C%E7%BE%8E%E7%9A%84%E5%B5%8C%E5%85%A5%E5%BC%8FIDE/</id>
    <published>2019-03-14T16:00:00.000Z</published>
    <updated>2020-07-07T04:56:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在我刚开始接触STM32的时候，使用的keil作为IDE，由于在这之前，我使用过VS, 使用过eclipse, 因而在我使用keil之后，实在难以忍受keil编辑器简陋的功能，可以说是极其糟糕的写代码体验</p><p>之后，我尝试过各种IDE，使用eclipse + keil，结果发现eclipse对C语言的支持也是鸡肋，使用emBits + gcc，需要和其他人协同的话就比较麻烦，之后发现了platformIO，也是使用gcc作为编译器，不过只支持HAL库</p><p>最后，通过使用VS Code + keil的方式，完美解决了写代码的体验问题，以及工程协作问题</p><span id="more"></span><p>其实网上使用VS Code作为编辑器，keil作为编译器的教程很多，不过基本都是需要在VS Code中编辑，然后在keil中编译，下载，调试，本文就要实现编辑，编译，下载，调试，全部使用VS Code</p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul><li>VS Code</li><li>keil</li><li>python</li><li>C&#x2F;C++(VS Code 插件)</li><li>Cortex-Debug(VS Code 插件)</li><li>其他VS Code插件(提升体验)</li></ul><h1 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h1><p>正式写代码之前，首先需要建立好一个工程，这个需要使用keil完成，包括工程配置，文件添加…</p><h1 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h1><p>在安装好VS Code插件之后，VS Code编写C代码本身体验就已经很好了，但是，因为我们使用的是keil环境，所以需要配置头文件包含，宏定义等</p><p>在工程路径的.vscode文件夹下打开c_cpp_properties.json文件，没有自己新建一个，内容配置如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;STM32&quot;</span>,</span><br><span class="line">            <span class="string">&quot;includePath&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;C:/Program Files (x86)/keil/ARM/ARMCC/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span>,</span><br><span class="line">                <span class="string">&quot;&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;browse&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;limitSymbolsToIncludedHeaders&quot;</span>: true,</span><br><span class="line">                <span class="string">&quot;databaseFilename&quot;</span>: <span class="string">&quot;$&#123;workspaceRoot&#125;/.vscode/.browse.c_cpp.db&quot;</span>,</span><br><span class="line">                <span class="string">&quot;path&quot;</span>: [</span><br><span class="line">                    <span class="string">&quot;C:/Program Files (x86)/keil/ARM/ARMCC/**&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;&quot;</span></span><br><span class="line">                ]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;defines&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;_DEBUG&quot;</span>,</span><br><span class="line">                <span class="string">&quot;UNICODE&quot;</span>,</span><br><span class="line">                <span class="string">&quot;_UNICODE&quot;</span>,</span><br><span class="line">                <span class="string">&quot;__CC_ARM&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;intelliSenseMode&quot;</span>: <span class="string">&quot;msvc-x64&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，需要在<code>includePath</code>和<code>path</code>中添加头文件路径，<code>$&#123;workspaceFolder&#125;/**</code>是工程路径，不用改动，额外需要添加的是keil的头文件路径</p><p>然后在<code>defines</code>中添加宏，也就是在keil的Options for Target的C++选项卡中配置的宏</p><p>然后就可以体验VS Code强大的代码提示，函数跳转等功能了(甩keil的编辑器一整个时代)</p><h1 id="编译、烧录"><a href="#编译、烧录" class="headerlink" title="编译、烧录"></a>编译、烧录</h1><p>编译和烧录通过VS Code的Task功能实现，通过Task，使用命令行的方式调用keil进行编译和烧录</p><p>keil本身就支持命令行调用，具体可以参考keil的手册，这里就不多说了，但是问题在于，使用命令行调用keil，不管是什么操作，他的输出都不会输出到控制台上!!!(要你这命令行支持有何用)</p><p>不过好在，keil支持输出到文件中，那我们就只能利用这个做点骚操作了————一边执行命令，一边读取文件内容并打印到控制台，从而就实现了输出在控制台上，我们就能直接在VS Code中看到编译过程了</p><p>为此，我编写了一个Python脚本，实现keil的命令行调用并同时读取文件输出到控制台</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding:UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">runing = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">readfile</span>(<span class="params">logfile</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(logfile, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(logfile, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">while</span> runing:</span><br><span class="line">            line = f.readline(<span class="number">1000</span>)</span><br><span class="line">            <span class="keyword">if</span> line != <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">                line = line.replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>)</span><br><span class="line">                <span class="built_in">print</span>(line, end = <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    modulePath = os.path.abspath(os.curdir)</span><br><span class="line">    logfile = modulePath + <span class="string">&#x27;/build.log&#x27;</span></span><br><span class="line">    cmd = <span class="string">&#x27;\&quot;C:/Program Files (x86)/keil/UV4/UV4.exe\&quot; &#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(sys.argv)):</span><br><span class="line">        cmd += sys.argv[i] + <span class="string">&#x27; &#x27;</span></span><br><span class="line">    cmd += <span class="string">&#x27;-j0 -o &#x27;</span> + logfile</span><br><span class="line">    thread = threading.Thread(target=readfile, args=(logfile,))</span><br><span class="line">    thread.start()</span><br><span class="line">    code = os.system(cmd)</span><br><span class="line">    runing = <span class="literal">False</span></span><br><span class="line">    thread.join()</span><br><span class="line">    sys.exit(code)</span><br></pre></td></tr></table></figure><p>此脚本需要结合VS Code的Task运行，通过配置Task，我们还需要匹配输出中的错误信息(编译错误)，实现在keil中，点击错误直接跳转到错误代码处，具体如何配置请参考VS Code的文档，这里给出我的Task</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // See https://go.microsoft.com/fwlink/?LinkId=<span class="number">733558</span></span><br><span class="line">    // <span class="keyword">for</span> the documentation about the tasks.json <span class="built_in">format</span></span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;2.0.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;tasks&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;label&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;shell&quot;</span>,</span><br><span class="line">            <span class="string">&quot;command&quot;</span>: <span class="string">&quot;py&quot;</span>,</span><br><span class="line">            <span class="string">&quot;args&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;-3&quot;</span>,</span><br><span class="line">                <span class="string">&quot;E:/scripts/build.py&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-b&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$&#123;config:uvprojxPath&#125;&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;group&quot;</span>: &#123;</span><br><span class="line">                <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line">                <span class="string">&quot;isDefault&quot;</span>: true</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">&quot;problemMatcher&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;owner&quot;</span>: <span class="string">&quot;c&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;fileLocation&quot;</span>: [<span class="string">&quot;relative&quot;</span>, <span class="string">&quot;$&#123;workspaceFolder&#125;/src/MDK-ARM&quot;</span>],</span><br><span class="line">                    <span class="string">&quot;pattern&quot;</span>: &#123;</span><br><span class="line">                        <span class="string">&quot;regexp&quot;</span>: <span class="string">&quot;^(.*)\\((\\d+)\\):\\s+(warning|error):\\s+(.*):\\s+(.*)$&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;file&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                        <span class="string">&quot;line&quot;</span>: <span class="number">2</span>,</span><br><span class="line">                        <span class="string">&quot;severity&quot;</span>: <span class="number">3</span>,</span><br><span class="line">                        <span class="string">&quot;code&quot;</span>: <span class="number">4</span>,</span><br><span class="line">                        <span class="string">&quot;message&quot;</span>: <span class="number">5</span>,</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;label&quot;</span>: <span class="string">&quot;rebuild&quot;</span>,</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;shell&quot;</span>,</span><br><span class="line">            <span class="string">&quot;command&quot;</span>: <span class="string">&quot;py&quot;</span>,</span><br><span class="line">            <span class="string">&quot;args&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;-3&quot;</span>,</span><br><span class="line">                <span class="string">&quot;E:/scripts/build.py&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-r&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$&#123;config:uvprojxPath&#125;&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;group&quot;</span>: <span class="string">&quot;build&quot;</span>,</span><br><span class="line">            <span class="string">&quot;problemMatcher&quot;</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">&quot;owner&quot;</span>: <span class="string">&quot;c&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;fileLocation&quot;</span>: [<span class="string">&quot;relative&quot;</span>, <span class="string">&quot;$&#123;workspaceFolder&#125;/src/MDK-ARM&quot;</span>],</span><br><span class="line">                    <span class="string">&quot;pattern&quot;</span>: &#123;</span><br><span class="line">                        <span class="string">&quot;regexp&quot;</span>: <span class="string">&quot;^(.*)\\((\\d+)\\):\\s+(warning|error):\\s+(.*):\\s+(.*)$&quot;</span>,</span><br><span class="line">                        <span class="string">&quot;file&quot;</span>: <span class="number">1</span>,</span><br><span class="line">                        <span class="string">&quot;line&quot;</span>: <span class="number">2</span>,</span><br><span class="line">                        <span class="string">&quot;severity&quot;</span>: <span class="number">3</span>,</span><br><span class="line">                        <span class="string">&quot;code&quot;</span>: <span class="number">4</span>,</span><br><span class="line">                        <span class="string">&quot;message&quot;</span>: <span class="number">5</span>,</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;label&quot;</span>: <span class="string">&quot;download&quot;</span>,</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;shell&quot;</span>,</span><br><span class="line">            <span class="string">&quot;command&quot;</span>: <span class="string">&quot;py&quot;</span>,</span><br><span class="line">            <span class="string">&quot;args&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;-3&quot;</span>,</span><br><span class="line">                <span class="string">&quot;E:/scripts/build.py&quot;</span>,</span><br><span class="line">                <span class="string">&quot;-f&quot;</span>,</span><br><span class="line">                <span class="string">&quot;$&#123;config:uvprojxPath&#125;&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;group&quot;</span>: <span class="string">&quot;test&quot;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;label&quot;</span>: <span class="string">&quot;open in keil&quot;</span>,</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;process&quot;</span>,</span><br><span class="line">            <span class="string">&quot;command&quot;</span>: <span class="string">&quot;$&#123;config:uvPath&#125;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;args&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;$&#123;config:uvprojxPath&#125;&quot;</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="string">&quot;group&quot;</span>: <span class="string">&quot;test&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于使用ARM Compiler 6编译的工程，build和rebuild中的problemMatcher应该配置为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;problemMatcher&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;owner&quot;</span>: <span class="string">&quot;c&quot;</span>,</span><br><span class="line">        <span class="string">&quot;fileLocation&quot;</span>: [<span class="string">&quot;relative&quot;</span>, <span class="string">&quot;$&#123;workspaceFolder&#125;/MDK-ARM&quot;</span>],</span><br><span class="line">        <span class="string">&quot;pattern&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;regexp&quot;</span>: <span class="string">&quot;^(.*)\\((\\d+)\\):\\s+(warning|error):\\s+(.*)$&quot;</span>,</span><br><span class="line">            <span class="string">&quot;file&quot;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">&quot;line&quot;</span>: <span class="number">2</span>,</span><br><span class="line">            <span class="string">&quot;severity&quot;</span>: <span class="number">3</span>,</span><br><span class="line">            <span class="string">&quot;message&quot;</span>: <span class="number">4</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>文件中的<code>config:uvPath</code>和<code>config:uvprojxPath</code>分别为keil的UV4.exe文件路径和工程路径(.uvprojx)，可以直接修改为具体路径，或者在VS Code的setting.json中增加对应的项</p><p>至此，我们已经完美实现了在VS Code中编辑，编译，下载了</p><blockquote><p>编译输出:</p><p><img src="https://s1.ax1x.com/2020/04/10/GIvGuR.png" alt="img_vscode_keil_complie.png"></p><p>有错误时输出：</p><p><img src="https://s1.ax1x.com/2020/04/10/GIvUUK.png" alt="img_vscode_keil_complie_error.png"></p><p>错误匹配：</p><p><img src="https://s1.ax1x.com/2020/04/10/GIvNE6.png" alt="img_vscode_keil_error_match.png"></p></blockquote><h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><p>调试需要使用到Cortex-Debug插件，以及arm gcc工具链，这部分可以参考Cortex-Debug的文档，说的比较详细</p><p>首先安装Cortex-Debug插件和arm gcc工具链，然后配置好环境路径，如果使用Jlink调试，需要下载Jlink套件，安转好之后，找到<code>JLinkGDBServerCL.exe</code>这个程序，在VS Code的设置中添加<code>&quot;cortex-debug.JLinkGDBServerPath&quot;: &quot;C:/Program Files (x86)/SEGGER/JLink_V630f/JLinkGDBServerCL.exe&quot;</code>，后面的路径是你自己的路径。</p><p>如果使用STLink调试，需要下载stutil工具，在GitHub上搜索即可找到，同样配置好路径即可。</p><p>以上步骤弄好之后，可以直接点击VS Code的调试按钮，此时会新建luanch.json文件，这个文件就是VS Code的调试配置文件，可参考我的文件进行配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 使用 IntelliSense 了解相关属性。</span><br><span class="line">    // 悬停以查看现有属性的描述。</span><br><span class="line">    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=<span class="number">830387</span></span><br><span class="line">    <span class="string">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Cortex Debug(JLINK)&quot;</span>,</span><br><span class="line">            <span class="string">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceRoot&#125;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;executable&quot;</span>: <span class="string">&quot;src/MDK-ARM/Objects/stm32_boot.axf&quot;</span>,</span><br><span class="line">            <span class="string">&quot;request&quot;</span>: <span class="string">&quot;attach&quot;</span>,</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;cortex-debug&quot;</span>,</span><br><span class="line">            <span class="string">&quot;servertype&quot;</span>: <span class="string">&quot;jlink&quot;</span>,</span><br><span class="line">            <span class="string">&quot;device&quot;</span>: <span class="string">&quot;STM32F407IG&quot;</span>,</span><br><span class="line">            <span class="string">&quot;svdFile&quot;</span>: <span class="string">&quot;C:/Program Files (x86)/keil/ARM/PACK/Keil/STM32F4xx_DFP/2.11.0/CMSIS/SVD/STM32F40x.svd&quot;</span>,</span><br><span class="line">            <span class="string">&quot;interface&quot;</span>: <span class="string">&quot;swd&quot;</span>,</span><br><span class="line">            <span class="string">&quot;ipAddress&quot;</span>: null,</span><br><span class="line">            <span class="string">&quot;serialNumber&quot;</span>: null</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Cortex Debug(ST-LINK)&quot;</span>,</span><br><span class="line">            <span class="string">&quot;cwd&quot;</span>: <span class="string">&quot;$&#123;workspaceRoot&#125;&quot;</span>,</span><br><span class="line">            <span class="string">&quot;executable&quot;</span>: <span class="string">&quot;src/MDK-ARM/Objects/stm32_boot.axf&quot;</span>,</span><br><span class="line">            <span class="string">&quot;request&quot;</span>: <span class="string">&quot;attach&quot;</span>,</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;cortex-debug&quot;</span>,</span><br><span class="line">            <span class="string">&quot;servertype&quot;</span>: <span class="string">&quot;stutil&quot;</span>,</span><br><span class="line">            <span class="string">&quot;svdFile&quot;</span>: <span class="string">&quot;C:/Program Files (x86)/keil/ARM/PACK/Keil/STM32F4xx_DFP/2.11.0/CMSIS/SVD/STM32F40x.svd&quot;</span>,</span><br><span class="line">            <span class="string">&quot;device&quot;</span>: <span class="string">&quot;STM32F407IG&quot;</span>,</span><br><span class="line">            <span class="string">&quot;v1&quot;</span>: false</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意其中几个需要修改的地方，<code>executable</code>修改为你的工程生成的目标文件，也就是工程的<code>.axf</code>文件，<code>svdFile</code>用于对MCU外设的监控，该文件可以在keil的安装路径中找到，可以参考我的路径去找</p><p>配置完成后，再次点击调试按钮即可进行调试</p><blockquote><p><img src="https://s1.ax1x.com/2020/04/10/GIvYHx.png" alt="img_vscode_keil_debug.png"></p></blockquote><p>相比keil自己的调试功能，VS Code还支持条件断点，可以设置命中条件，次数等，可以极大的方便调试</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过以上的配置，我们基本上，除了建立工程和往工程中添加文件，其他完全不需要打开keil，所以也无妨说一句，再见，智障keil</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在我刚开始接触STM32的时候，使用的keil作为IDE，由于在这之前，我使用过VS, 使用过eclipse, 因而在我使用keil之后，实在难以忍受keil编辑器简陋的功能，可以说是极其糟糕的写代码体验&lt;/p&gt;
&lt;p&gt;之后，我尝试过各种IDE，使用eclipse + keil，结果发现eclipse对C语言的支持也是鸡肋，使用emBits + gcc，需要和其他人协同的话就比较麻烦，之后发现了platformIO，也是使用gcc作为编译器，不过只支持HAL库&lt;/p&gt;
&lt;p&gt;最后，通过使用VS Code + keil的方式，完美解决了写代码的体验问题，以及工程协作问题&lt;/p&gt;</summary>
    
    
    
    <category term="嵌入式" scheme="http://nevermindzzt.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
    <category term="嵌入式" scheme="http://nevermindzzt.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="STM32" scheme="http://nevermindzzt.github.io/tags/STM32/"/>
    
    <category term="VS Code" scheme="http://nevermindzzt.github.io/tags/VS-Code/"/>
    
  </entry>
  
  <entry>
    <title>在嵌入式系统中实现简单的shell</title>
    <link href="http://nevermindzzt.github.io/2018/07/15/%E5%9C%A8%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84shell/"/>
    <id>http://nevermindzzt.github.io/2018/07/15/%E5%9C%A8%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84shell/</id>
    <published>2018-07-14T16:00:00.000Z</published>
    <updated>2020-07-07T04:56:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>对于嵌入式系统而言，特别对于没有使用操作系统，裸机运行程序的嵌入式系统，如何高效便捷的进行系统调试往往是一个比较令人头疼的问题。不久前，我接触到一个国产嵌入式操作系统，Thread RTOS，其中，该系统集成的finsh shell工具让我有种眼前一亮的感觉，它将shell工具引入到嵌入式系统中，极大的方便了系统的调试。</p><p>然而，finsh shell运行在操作系统之上，体积也比较大，对于某些小型嵌入式设备，基本是与其无缘了，既然如此，我们为何不自己编写一个shell呢。</p><span id="more"></span><p>我们首先对shell的运行原理进行分析，通过在命令行输入命令，shell对命令进行解析，然后执行相应的操作，更通俗的，就是使用输入的字符串，匹配到对应的函数，然后执行。那么，我们需要建立一个命令-函数的一一对应的关系，定义结构体。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> *name;                                              <span class="comment">//shell命令名称</span></span><br><span class="line">    shellFunction function;                                     <span class="comment">//shell命令函数</span></span><br><span class="line">    <span class="type">uint8_t</span> *desc;                                              <span class="comment">//shell命令描述</span></span><br><span class="line">&#125;SHELL_CommandTypeDef;                                          <span class="comment">//shell命令定义</span></span><br></pre></td></tr></table></figure><p>其中，shellFunction为函数指针类型，定义为</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*shellFunction)</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>有了定义之后，我们建立一个表，将所有的命令以及对应的函数进行声明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* shell 命令表，使用 &#123;command, function, description&#125; 的格式添加命令</span></span><br><span class="line"><span class="comment">* 其中</span></span><br><span class="line"><span class="comment">* command   为命令，字符串格式，长度不能超过 SHELL_PARAMETER_MAX_LENGTH</span></span><br><span class="line"><span class="comment">*           若不使用带参命令，则长度不超过SHELL_COMMAND_MAX_LENGTH</span></span><br><span class="line"><span class="comment">* function  为该命令调用的函数，支持(void *)(void)类型的无参函数以及与带参主函数</span></span><br><span class="line"><span class="comment">*           类似的(void *)(uint32_t argc, uint8_t *argv[])类型的带参函数，其中，</span></span><br><span class="line"><span class="comment">*           argc 为参数个数，argv 为参数，参数皆为字符串格式，需自行进行数据转换</span></span><br><span class="line"><span class="comment">* description 为对命令的描述，字符串格式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">const</span> SHELL_CommandTypeDef shellCommandList[] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*command               function                description*/</span></span><br><span class="line">    &#123;(<span class="type">uint8_t</span> *)<span class="string">&quot;letter&quot;</span>,   shellLetter,            (<span class="type">uint8_t</span> *)<span class="string">&quot;letter shell&quot;</span>&#125;,</span><br><span class="line">    &#123;(<span class="type">uint8_t</span> *)<span class="string">&quot;reboot&quot;</span>,   shellReboot,            (<span class="type">uint8_t</span> *)<span class="string">&quot;reboot system&quot;</span>&#125;,</span><br><span class="line">    &#123;(<span class="type">uint8_t</span> *)<span class="string">&quot;help&quot;</span>,     shellShowCommandList,   (<span class="type">uint8_t</span> *)<span class="string">&quot;show command list&quot;</span>&#125;,</span><br><span class="line">    &#123;(<span class="type">uint8_t</span> *)<span class="string">&quot;clear&quot;</span>,    shellClear,             (<span class="type">uint8_t</span> *)<span class="string">&quot;clear command line&quot;</span>&#125;,</span><br><span class="line">    &#123;(<span class="type">uint8_t</span> *)<span class="string">&quot;iap&quot;</span>,      iapMain,                (<span class="type">uint8_t</span> *)<span class="string">&quot;iap&quot;</span>&#125;,</span><br><span class="line">    &#123;(<span class="type">uint8_t</span> *)<span class="string">&quot;tftp&quot;</span>,     iapTftp,                (<span class="type">uint8_t</span> *)<span class="string">&quot;start TFTP server&quot;</span>&#125;,</span><br><span class="line">    &#123;(<span class="type">uint8_t</span> *)<span class="string">&quot;userApp&quot;</span>,  iapJumpToApplication,   (<span class="type">uint8_t</span> *)<span class="string">&quot;run user application&quot;</span>&#125;,</span><br><span class="line">    &#123;(<span class="type">uint8_t</span> *)<span class="string">&quot;erase&quot;</span>,    (<span class="built_in">void</span> (*)())iapErase,   (<span class="type">uint8_t</span> *)<span class="string">&quot;erase user application&quot;</span>&#125;,</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SHELL_USE_PARAMETER == 1    <span class="comment">/*带参函数命令*/</span></span></span><br><span class="line">    &#123;(<span class="type">uint8_t</span> *)<span class="string">&quot;paraTest&quot;</span>, (<span class="built_in">void</span> (*)())shellParaTest, (<span class="type">uint8_t</span> *)<span class="string">&quot;test parameter&quot;</span>&#125;,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后，我们只需要获得输入的命令，并将其和命令表中的命令进行匹配，然后执行相应的函数即可，完整代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******************************************************************************</span></span><br><span class="line"><span class="comment">*@function  shellHandler</span></span><br><span class="line"><span class="comment">*@brief     shell处理函数</span></span><br><span class="line"><span class="comment">*@param     receiveData     接收到的数据</span></span><br><span class="line"><span class="comment">*@retval    None</span></span><br><span class="line"><span class="comment">*@author    Letter</span></span><br><span class="line"><span class="comment">*@note      此函数被shellMain函数调用，若使用shellMain阻塞式运行shell，直接调用</span></span><br><span class="line"><span class="comment">*           shellMain函数即可，但不建议这样做，建议在无操作系统情况下，在shell</span></span><br><span class="line"><span class="comment">*           输入触发的中断中调用此函数（通常为串口中断），此时无需调用shellMain，</span></span><br><span class="line"><span class="comment">*           shell也为非阻塞式，操作系统情况下，通常将此函数交给shell输入设备的</span></span><br><span class="line"><span class="comment">*           任务处理</span></span><br><span class="line"><span class="comment">*******************************************************************************/</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellHandler</span><span class="params">(<span class="type">uint8_t</span> receiveData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">uint8_t</span> runFlag;</span><br><span class="line">    <span class="type">static</span> CONTROL_Status controlFlag = CONTROL_FREE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (receiveData)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;\r&#x27;</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;\n&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> (shellCommandFlag &gt;= SHELL_COMMAND_MAX_LENGTH - <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">shellDisplay</span>(<span class="string">&quot;\r\nError: Command is too long\r\n&quot;</span>);</span><br><span class="line">                shellCommandBuff[shellCommandFlag] = <span class="number">0</span>;</span><br><span class="line">                shellCommandFlag = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">shellDisplay</span>(SHELL_COMMAND);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (shellCommandFlag == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">shellDisplay</span>(SHELL_COMMAND);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                shellCommandBuff[shellCommandFlag++] = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SHELL_USE_PARAMETER == 1</span></span><br><span class="line">                commandCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="type">uint8_t</span> j = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int8_t</span> i = <span class="number">0</span>; i &lt; shellCommandFlag; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (shellCommandBuff[i] != <span class="string">&#x27; &#x27;</span> &amp;&amp;</span><br><span class="line">                        shellCommandBuff[i] != <span class="string">&#x27;\t&#x27;</span> &amp;&amp;</span><br><span class="line">                        shellCommandBuff[i] != <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        commandPara[commandCount][j++] = shellCommandBuff[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span> (j != <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            commandPara[commandCount][j] = <span class="number">0</span>;</span><br><span class="line">                            commandCount ++;</span><br><span class="line">                            j = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                shellCommandFlag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (commandCount == <span class="number">0</span>)                      <span class="comment">//是否为无效指令</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">shellDisplay</span>(SHELL_COMMAND);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SHELL_USE_HISTORY ==1</span></span><br><span class="line">                <span class="built_in">shellStringCopy</span>(shellHistoryCommand[shellHistoryFlag++], shellCommandBuff);</span><br><span class="line">                <span class="keyword">if</span> (++shellHistoryCount &gt; SHELL_HISTORY_MAX_NUMBER)</span><br><span class="line">                &#123;</span><br><span class="line">                    shellHistoryCount = SHELL_HISTORY_MAX_NUMBER;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shellHistoryFlag &gt;= SHELL_HISTORY_MAX_NUMBER)</span><br><span class="line">                &#123;</span><br><span class="line">                    shellHistoryFlag = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                shellHistoryOffset = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">                <span class="built_in">shellDisplay</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">                runFlag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int8_t</span> i = <span class="built_in">sizeof</span>(shellCommandList) / <span class="built_in">sizeof</span>(SHELL_CommandTypeDef) - <span class="number">1</span>;</span><br><span class="line">                     i &gt;=  <span class="number">0</span>; i--)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">strcmp</span>((<span class="type">const</span> <span class="type">char</span> *)commandPara[<span class="number">0</span>],</span><br><span class="line">                        (<span class="type">const</span> <span class="type">char</span> *)shellCommandList[i].name) == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        runFlag = <span class="number">1</span>;</span><br><span class="line">                        shellCommandList[i].<span class="built_in">function</span>(commandCount, commandPointer);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">/*SHELL_USE_PARAMETER == 1*/</span></span></span><br><span class="line"></span><br><span class="line">                shellCommandBuff[shellCommandFlag] = <span class="number">0</span>;</span><br><span class="line">                shellCommandFlag = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">shellDisplay</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">                runFlag = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int8_t</span> i = <span class="built_in">sizeof</span>(shellCommandList) / <span class="built_in">sizeof</span>(SHELL_CommandTypeDef) - <span class="number">1</span>;</span><br><span class="line">                     i &gt;=  <span class="number">0</span>; i--)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">strcmp</span>((<span class="type">const</span> <span class="type">char</span> *)shellCommandBuff,</span><br><span class="line">                        (<span class="type">const</span> <span class="type">char</span> *)shellCommandList[i].name) == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        runFlag = <span class="number">1</span>;</span><br><span class="line">                        shellCommandList[i].<span class="built_in">function</span>();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*SHELL_USE_PARAMETER == 1*/</span></span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (runFlag == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">shellDisplay</span>(<span class="string">&quot;Command not found&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">shellDisplay</span>(SHELL_COMMAND);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x08</span>:                                          <span class="comment">//退格</span></span><br><span class="line">            <span class="keyword">if</span> (shellCommandFlag != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                shellCommandFlag--;</span><br><span class="line">                <span class="built_in">shellBackspace</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;\t&#x27;</span>:                                          <span class="comment">//制表符</span></span><br><span class="line">        <span class="meta">#<span class="keyword">if</span> SHELL_USE_HISTORY == 1</span></span><br><span class="line">            <span class="keyword">if</span> (shellHistoryCount != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">shellBackspace</span>(shellCommandFlag);</span><br><span class="line">                shellCommandFlag = <span class="built_in">shellStringCopy</span>(shellCommandBuff,</span><br><span class="line">                                   shellHistoryCommand[(shellHistoryFlag + SHELL_HISTORY_MAX_NUMBER - <span class="number">1</span>)</span><br><span class="line">                                                        % SHELL_HISTORY_MAX_NUMBER]);</span><br><span class="line">                <span class="built_in">shellDisplay</span>(shellCommandBuff);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>                                            <span class="comment">//无历史命令，输入help</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">shellBackspace</span>(shellCommandFlag);</span><br><span class="line">                shellCommandFlag = <span class="number">4</span>;</span><br><span class="line">                <span class="built_in">shellStringCopy</span>(shellCommandBuff, (<span class="type">uint8_t</span> *)<span class="string">&quot;help&quot;</span>);</span><br><span class="line">                <span class="built_in">shellDisplay</span>(shellCommandBuff);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x1B</span>:                                          <span class="comment">//控制键</span></span><br><span class="line">            controlFlag = CONTROL_STEP_ONE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">switch</span> ((<span class="type">uint8_t</span>)controlFlag)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> CONTROL_STEP_TWO:</span><br><span class="line">                    <span class="keyword">if</span> (receiveData == <span class="number">0x41</span>)                <span class="comment">//方向上键</span></span><br><span class="line">                    &#123;</span><br><span class="line">                    <span class="meta">#<span class="keyword">if</span> SHELL_USE_HISTORY == 1</span></span><br><span class="line">                        <span class="built_in">shellBackspace</span>(shellCommandFlag);</span><br><span class="line">                        <span class="keyword">if</span> (shellHistoryOffset--</span><br><span class="line">                            &lt;= -((shellHistoryCount &gt; shellHistoryFlag)</span><br><span class="line">                                ? shellHistoryCount : shellHistoryFlag))</span><br><span class="line">                        &#123;</span><br><span class="line">                            shellHistoryOffset</span><br><span class="line">                            = -((shellHistoryCount &gt; shellHistoryFlag)</span><br><span class="line">                                ? shellHistoryCount : shellHistoryFlag);</span><br><span class="line">                        &#125;</span><br><span class="line">                        shellCommandFlag = <span class="built_in">shellStringCopy</span>(shellCommandBuff,</span><br><span class="line">                            shellHistoryCommand[(shellHistoryFlag + SHELL_HISTORY_MAX_NUMBER</span><br><span class="line">                                                 + shellHistoryOffset) % SHELL_HISTORY_MAX_NUMBER]);</span><br><span class="line">                        <span class="built_in">shellDisplay</span>(shellCommandBuff);</span><br><span class="line">                    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                        <span class="comment">//shellDisplay(&quot;up\r\n&quot;);</span></span><br><span class="line">                    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (receiveData == <span class="number">0x42</span>)           <span class="comment">//方向下键</span></span><br><span class="line">                    &#123;</span><br><span class="line">                    <span class="meta">#<span class="keyword">if</span> SHELL_USE_HISTORY == 1</span></span><br><span class="line">                        <span class="keyword">if</span> (++shellHistoryOffset &gt;= <span class="number">0</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            shellHistoryOffset = <span class="number">-1</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="built_in">shellBackspace</span>(shellCommandFlag);</span><br><span class="line">                        shellCommandFlag = <span class="built_in">shellStringCopy</span>(shellCommandBuff,</span><br><span class="line">                            shellHistoryCommand[(shellHistoryFlag + SHELL_HISTORY_MAX_NUMBER</span><br><span class="line">                                                 + shellHistoryOffset) % SHELL_HISTORY_MAX_NUMBER]);</span><br><span class="line">                        <span class="built_in">shellDisplay</span>(shellCommandBuff);</span><br><span class="line">                    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">                        <span class="comment">//shellDisplay(&quot;down\r\n&quot;);</span></span><br><span class="line">                    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (receiveData == <span class="number">0x43</span>)           <span class="comment">//方向右键</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//shellDisplay(&quot;right\r\n&quot;);</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (receiveData == <span class="number">0x44</span>)           <span class="comment">//方向左键</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">//shellDisplay(&quot;left\r\n&quot;);</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        controlFlag = CONTROL_FREE;</span><br><span class="line">                        <span class="keyword">goto</span> normal;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> CONTROL_STEP_ONE:</span><br><span class="line">                    <span class="keyword">if</span> (receiveData == <span class="number">0x5B</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        controlFlag = CONTROL_STEP_TWO;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        controlFlag = CONTROL_FREE;</span><br><span class="line">                        <span class="keyword">goto</span> normal;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> CONTROL_FREE:                          <span class="comment">//正常按键处理</span></span><br><span class="line">normal:             <span class="keyword">if</span> (shellCommandFlag &lt; SHELL_COMMAND_MAX_LENGTH - <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        shellCommandBuff[shellCommandFlag++] = receiveData;</span><br><span class="line">                        <span class="built_in">shellDisplayByte</span>(receiveData);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        shellCommandFlag++;</span><br><span class="line">                        <span class="built_in">shellDisplayByte</span>(receiveData);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用串口进行命令的输入和输出，在输入命令并回车之后，程序解析命令，根据空格将输入分开为命令和参数，对命令进行匹配，匹配到命令之后，执行函数。</p><p>完整代码之后会同步到github。</p><p>end</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于嵌入式系统而言，特别对于没有使用操作系统，裸机运行程序的嵌入式系统，如何高效便捷的进行系统调试往往是一个比较令人头疼的问题。不久前，我接触到一个国产嵌入式操作系统，Thread RTOS，其中，该系统集成的finsh shell工具让我有种眼前一亮的感觉，它将shell工具引入到嵌入式系统中，极大的方便了系统的调试。&lt;/p&gt;
&lt;p&gt;然而，finsh shell运行在操作系统之上，体积也比较大，对于某些小型嵌入式设备，基本是与其无缘了，既然如此，我们为何不自己编写一个shell呢。&lt;/p&gt;</summary>
    
    
    
    <category term="letter shell" scheme="http://nevermindzzt.github.io/categories/letter-shell/"/>
    
    
    <category term="嵌入式" scheme="http://nevermindzzt.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="STM32" scheme="http://nevermindzzt.github.io/tags/STM32/"/>
    
  </entry>
  
  <entry>
    <title>一种不依赖计时器的键盘长按，双击实现</title>
    <link href="http://nevermindzzt.github.io/2018/04/07/%E4%B8%80%E7%A7%8D%E4%B8%8D%E4%BE%9D%E8%B5%96%E8%AE%A1%E6%97%B6%E5%99%A8%E7%9A%84%E9%94%AE%E7%9B%98%E9%95%BF%E6%8C%89%EF%BC%8C%E5%8F%8C%E5%87%BB%E5%AE%9E%E7%8E%B0/"/>
    <id>http://nevermindzzt.github.io/2018/04/07/%E4%B8%80%E7%A7%8D%E4%B8%8D%E4%BE%9D%E8%B5%96%E8%AE%A1%E6%97%B6%E5%99%A8%E7%9A%84%E9%94%AE%E7%9B%98%E9%95%BF%E6%8C%89%EF%BC%8C%E5%8F%8C%E5%87%BB%E5%AE%9E%E7%8E%B0/</id>
    <published>2018-04-06T16:00:00.000Z</published>
    <updated>2020-07-07T04:56:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面一段时间在考虑矩阵键盘的驱动方式，其中，在按键长按这个点上，网上的好多思路都是建立在计时器计时和中断的基础上的，那么，能不能再不用中断和计时器的情况下，实现按键的长按和双击的判断呢。</p><p>在判断按键被按下之后，如果我们对按键释放的时间进行计时，就可以实现按键长按的判断了。建立在这个基础上，如果我们在按键释放之后，延时一段时间再一次判断同一个按键是不是被释放，是不是就可以实现双击的判断了。</p><span id="more"></span><p>有了思路之后，代码实现就比较容易了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> <span class="title function_">KEY_Scan</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> lastKeyValue;                                <span class="comment">//记录上次键值，放置连按触发</span></span><br><span class="line"><span class="type">uint16_t</span> count;</span><br><span class="line"><span class="type">uint8_t</span> i;</span><br><span class="line"><span class="type">uint8_t</span> scanData = <span class="number">0</span>;</span><br><span class="line"><span class="type">uint8_t</span> keyValue = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">uint8_t</span> writeData[] = &#123;<span class="number">0x0E</span>, <span class="number">0x0D</span>, <span class="number">0x0B</span>, <span class="number">0x07</span>&#125;;</span><br><span class="line"></span><br><span class="line">KEY_Write(<span class="number">0x00</span>);                                            <span class="comment">//写键盘列</span></span><br><span class="line">count = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">while</span>((KEY_Read() == <span class="number">0x0F</span>) &amp;&amp; (count != <span class="number">0</span>))                 <span class="comment">//等待键盘按下，10ms超时</span></span><br><span class="line">&#123;</span><br><span class="line">delay_us(<span class="number">1</span>);</span><br><span class="line">count--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (count == <span class="number">0</span>)                                             <span class="comment">//若等待超时，按键无效</span></span><br><span class="line">&#123;</span><br><span class="line">lastKeyValue = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">delay_ms(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)                                     <span class="comment">//按列扫描</span></span><br><span class="line">&#123;</span><br><span class="line">KEY_Write(writeData[i]);                                <span class="comment">//写列数据</span></span><br><span class="line">delay_us(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">switch</span> (KEY_Read())                                     <span class="comment">//读行数据并处理</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0x0E</span>:</span><br><span class="line">scanData += <span class="number">1</span>;</span><br><span class="line">keyValue = scanData;                            <span class="comment">//记录键值</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">0x0D</span>:</span><br><span class="line">scanData += <span class="number">2</span>;</span><br><span class="line">keyValue = scanData;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">0x0B</span>:</span><br><span class="line">scanData += <span class="number">3</span>;</span><br><span class="line">keyValue = scanData;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="number">0x07</span>:</span><br><span class="line">scanData += <span class="number">4</span>;</span><br><span class="line">keyValue = scanData;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">scanData += <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (keyValue == <span class="number">0</span>)                                          <span class="comment">//若无按键按下，返回</span></span><br><span class="line">&#123;</span><br><span class="line">lastKeyValue = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> keyValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">KEY_Write(<span class="number">0x00</span>);                                            <span class="comment">//列全写0</span></span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((KEY_Read() != <span class="number">0x0F</span>) &amp;&amp; count &lt; KEY_LONG_PRESS_MAX_TIME) <span class="comment">//读行键值，若有按键按下则计时</span></span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">delay_ms(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (count &gt; KEY_SHORT_PRESS_MAX_TIME)                       <span class="comment">//若计时超过KEY_SHORT_PRESS_MAX_TIME，为长按</span></span><br><span class="line">&#123;</span><br><span class="line">keyValue += <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span>KEY_DOUBLE_CLICK                                        <span class="comment">//双击</span></span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">delay_ms(KEY_DOUBLE_CLICK_DELAY);                       <span class="comment">//延时一段时间，等待双击的第二次按下</span></span><br><span class="line">KEY_Write(writeData[(keyValue - <span class="number">1</span>) / <span class="number">4</span>]);</span><br><span class="line">delay_us(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (KEY_Read() == writeData[(keyValue - <span class="number">1</span>) % <span class="number">4</span>])        <span class="comment">//若读取到的按键和第一次按下的键值一样，为双击</span></span><br><span class="line">&#123;</span><br><span class="line">keyValue += <span class="number">40</span>;</span><br><span class="line">delay_ms(<span class="number">10</span>);</span><br><span class="line">KEY_Write(<span class="number">0x00</span>);</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ((KEY_Read() != <span class="number">0x0F</span>) &amp;&amp; count &lt; <span class="number">500</span>)         <span class="comment">//等待按键释放</span></span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">delay_ms(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((lastKeyValue == keyValue) || (lastKeyValue == keyValue + <span class="number">20</span>) || (lastKeyValue == keyValue <span class="number">-20</span>))    <span class="comment">//防止连按触发</span></span><br><span class="line">&#123;</span><br><span class="line">keyValue = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">lastKeyValue = keyValue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> keyValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>end</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前面一段时间在考虑矩阵键盘的驱动方式，其中，在按键长按这个点上，网上的好多思路都是建立在计时器计时和中断的基础上的，那么，能不能再不用中断和计时器的情况下，实现按键的长按和双击的判断呢。&lt;/p&gt;
&lt;p&gt;在判断按键被按下之后，如果我们对按键释放的时间进行计时，就可以实现按键长按的判断了。建立在这个基础上，如果我们在按键释放之后，延时一段时间再一次判断同一个按键是不是被释放，是不是就可以实现双击的判断了。&lt;/p&gt;</summary>
    
    
    
    <category term="嵌入式" scheme="http://nevermindzzt.github.io/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    
    <category term="嵌入式" scheme="http://nevermindzzt.github.io/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"/>
    
    <category term="STM32" scheme="http://nevermindzzt.github.io/tags/STM32/"/>
    
  </entry>
  
  <entry>
    <title>解决Visio“操作系统当前的配置无法运行此程序”问题</title>
    <link href="http://nevermindzzt.github.io/2018/03/07/%E8%A7%A3%E5%86%B3Visio2016%E2%80%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BD%93%E5%89%8D%E7%9A%84%E9%85%8D%E7%BD%AE%E6%97%A0%E6%B3%95%E8%BF%90%E8%A1%8C%E6%AD%A4%E7%A8%8B%E5%BA%8F%E2%80%9D%E9%97%AE%E9%A2%98/"/>
    <id>http://nevermindzzt.github.io/2018/03/07/%E8%A7%A3%E5%86%B3Visio2016%E2%80%9C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BD%93%E5%89%8D%E7%9A%84%E9%85%8D%E7%BD%AE%E6%97%A0%E6%B3%95%E8%BF%90%E8%A1%8C%E6%AD%A4%E7%A8%8B%E5%BA%8F%E2%80%9D%E9%97%AE%E9%A2%98/</id>
    <published>2018-03-06T16:00:00.000Z</published>
    <updated>2020-07-07T04:56:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于要写论文的原因，需要用到流程图，于是想装一个Visio用用。从下载Visio镜像到安装完成，一切都很顺利，但是安装完成之后打开，竟然提示“操作系统的当前配置无法运行此程序”，表示一脸懵逼…</p><span id="more"></span><p>在网上搜索找到很多说法，包括改注册表什么的，都没有成功。后面发现，office2016和Visio的镜像其实是一样的，只不过里面的setup.exe不同，于是替换Visio镜像的setup到解压后的office镜像中，在这里安装，然后就安装成功了。</p><p>个人猜测应该是两个镜像之间的微小差别导致的不兼容，有同样问题的可以试试这个方案。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;由于要写论文的原因，需要用到流程图，于是想装一个Visio用用。从下载Visio镜像到安装完成，一切都很顺利，但是安装完成之后打开，竟然提示“操作系统的当前配置无法运行此程序”，表示一脸懵逼…&lt;/p&gt;</summary>
    
    
    
    
    <category term="office" scheme="http://nevermindzzt.github.io/tags/office/"/>
    
    <category term="Software" scheme="http://nevermindzzt.github.io/tags/Software/"/>
    
  </entry>
  
</feed>
